<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Podfree Editor</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="icon" href="favicon.ico" />
  <style>
    :root {
      color-scheme: light dark;
      --bg: #0f172a;
      --panel: rgba(15, 23, 42, 0.8);
      --panel-border: rgba(148, 163, 184, 0.18);
      --text: #f8fafc;
      --muted: #94a3b8;
      --accent: #38bdf8;
      font-family: "Inter", "Segoe UI", system-ui, -apple-system, sans-serif;
    }

    * {
      box-sizing: border-box;
    }

    ::selection {
      background: #3b82f6;
      color: white;
    }

    ::-moz-selection {
      background: #3b82f6;
      color: white;
    }

    body {
      margin: 0;
      min-height: 100vh;
      background: radial-gradient(circle at top left, rgba(56, 189, 248, 0.18), transparent 55%),
                  radial-gradient(circle at bottom right, rgba(244, 114, 182, 0.1), transparent 58%),
                  var(--bg);
      color: var(--text);
      display: flex;
      flex-direction: column;
      gap: 1.5rem;
      padding: 1.5rem clamp(1rem, 2vw, 2.5rem) 2.5rem;
    }

    header {
      max-width: 960px;
      margin: 0 auto;
      width: 100%;
      display: flex;
      flex-direction: column;
      gap: 0.75rem;
    }

    .brand-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 1rem;
      flex-wrap: wrap;
    }

    .brand-actions {
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    body.modal-open {
      overflow: hidden;
    }

    .icon-button {
      border: 1px solid rgba(148, 163, 184, 0.3);
      background: rgba(148, 163, 184, 0.18);
      color: var(--text);
      display: inline-flex;
      align-items: center;
      justify-content: center;
      padding: 0.4rem 0.55rem;
      border-radius: 10px;
      cursor: pointer;
      gap: 0.4rem;
      transition: background 0.2s ease, color 0.2s ease, transform 0.18s ease;
    }

    .icon-button:hover {
      background: rgba(56, 189, 248, 0.26);
      color: var(--text);
      transform: translateY(-1px);
    }

    .icon-button svg {
      width: 20px;
      height: 20px;
      fill: currentColor;
    }

    .icon-button.small {
      padding: 0.25rem;
      border-radius: 8px;
      gap: 0;
    }

    .icon-button.with-label {
      padding: 0.4rem 0.75rem;
      font-size: 0.85rem;
      letter-spacing: 0.04em;
      text-transform: uppercase;
    }

    .icon-button.with-label span {
      font-size: 0.78rem;
      color: var(--text);
    }


    .site-logo {
      height: 48px;
    }

    .top-nav {
      display: inline-flex;
      gap: 0.5rem;
      background: rgba(15, 23, 42, 0.6);
      border: 1px solid rgba(148, 163, 184, 0.2);
      border-radius: 999px;
      padding: 0.35rem;
    }

    .nav-link {
      color: var(--muted);
      text-decoration: none;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      font-size: 0.76rem;
      padding: 0.35rem 0.9rem;
      border-radius: 999px;
      transition: background 0.2s ease, color 0.2s ease;
    }

    .nav-link:hover {
      background: rgba(148, 163, 184, 0.25);
      color: var(--text);
    }

    .nav-link.active {
      background: var(--accent);
      color: #0b1120;
      font-weight: 600;
    }

    .nav-link.workspace-required {
      display: none;
    }

    .nav-link.workspace-required.visible {
      display: block;
    }

    h1 {
      margin: 0;
      font-size: clamp(1.9rem, 1.2rem + 2vw, 2.6rem);
    }

    .info {
      color: var(--muted);
      font-size: 0.95rem;
      margin: 0;
    }

    .title-form {
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
      margin-top: 0.5rem;
    }

    .title-form label {
      font-size: 0.82rem;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      color: var(--muted);
    }

    .title-row {
      display: flex;
      gap: 0.5rem;
      align-items: center;
      flex-wrap: wrap;
    }

    #title-input {
      flex: 1 1 280px;
      min-width: 220px;
      padding: 0.55rem 0.75rem;
      border-radius: 10px;
      border: 1px solid rgba(148, 163, 184, 0.3);
      background: rgba(15, 23, 42, 0.7);
      color: var(--text);
      font-size: 0.95rem;
    }

    #title-input:disabled {
      opacity: 0.6;
      cursor: wait;
    }

    #title-save {
      border: 1px solid rgba(148, 163, 184, 0.3);
      background: rgba(148, 163, 184, 0.18);
      color: var(--text);
      font-size: 0.85rem;
      padding: 0.5rem 0.95rem;
      border-radius: 10px;
      cursor: pointer;
      transition: background 0.2s ease;
    }

    #title-save:hover:not(:disabled) {
      background: rgba(56, 189, 248, 0.26);
    }

    #title-save:disabled {
      opacity: 0.6;
      cursor: wait;
    }

    .title-status {
      font-size: 0.82rem;
      color: var(--muted);
    }

    .participant-form {
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
      margin-top: 0.5rem;
    }

    .participant-form label {
      font-size: 0.82rem;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      color: var(--muted);
    }

    .participant-row {
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      gap: 0.5rem;
    }

    .participant-field {
      display: flex;
      flex-direction: column;
      gap: 0.35rem;
      flex: 1 1 200px;
      min-width: 180px;
    }

    .speaker-select {
      padding: 0.35rem 0.5rem;
      border-radius: 8px;
      border: 1px solid rgba(148, 163, 184, 0.3);
      background: rgba(15, 23, 42, 0.7);
      color: var(--text);
      font-size: 0.78rem;
      cursor: pointer;
      transition: border-color 0.2s ease;
    }

    .speaker-select:hover:not(:disabled) {
      border-color: rgba(56, 189, 248, 0.5);
    }

    .speaker-select:disabled {
      opacity: 0.6;
      cursor: wait;
    }

    .participant-row input {
      width: 100%;
      padding: 0.5rem 0.7rem;
      border-radius: 10px;
      border: 1px solid rgba(148, 163, 184, 0.3);
      background: rgba(15, 23, 42, 0.7);
      color: var(--text);
      font-size: 0.9rem;
    }

    .participant-row input:disabled {
      opacity: 0.6;
      cursor: wait;
    }

    #participant-save {
      border: 1px solid rgba(148, 163, 184, 0.3);
      background: rgba(148, 163, 184, 0.18);
      color: var(--text);
      font-size: 0.85rem;
      padding: 0.5rem 0.95rem;
      border-radius: 10px;
      cursor: pointer;
      transition: background 0.2s ease;
    }

    #participant-save:hover:not(:disabled) {
      background: rgba(56, 189, 248, 0.26);
    }

    #participant-save:disabled {
      opacity: 0.6;
      cursor: wait;
    }

    .participant-status {
      font-size: 0.82rem;
      color: var(--muted);
    }

    .participant-info {
      display: flex;
      gap: 0.6rem;
      flex-wrap: wrap;
      margin-top: 0.5rem;
    }

    .participant-pill {
      display: inline-flex;
      align-items: center;
      gap: 0.35rem;
      border-radius: 999px;
      padding: 0.35rem 0.85rem;
      font-size: 0.82rem;
      letter-spacing: 0.05em;
      text-transform: uppercase;
      border: 1px solid rgba(148, 163, 184, 0.28);
      background: rgba(148, 163, 184, 0.16);
      color: var(--muted);
    }

    .participant-pill strong {
      color: var(--text);
      font-weight: 600;
      letter-spacing: 0.08em;
    }

    .participant-pill.interviewer {
      border-color: rgba(56, 189, 248, 0.4);
      background: rgba(56, 189, 248, 0.18);
    }

    .participant-pill.guest {
      border-color: rgba(74, 222, 128, 0.4);
      background: rgba(74, 222, 128, 0.18);
    }

    .participant-pill.missing {
      border-color: rgba(148, 163, 184, 0.2);
      background: rgba(148, 163, 184, 0.12);
      color: rgba(148, 163, 184, 0.8);
    }

    .participant-info.all-missing .participant-pill {
      opacity: 0.65;
    }

    .layout {
      flex: 1;
      display: flex;
      flex-wrap: wrap;
      gap: 1.5rem;
      width: 100%;
      max-width: 1140px;
      margin: 0 auto;
    }

    .panel {
      background: var(--panel);
      border: 1px solid var(--panel-border);
      border-radius: 24px;
      padding: clamp(1.2rem, 1rem + 1vw, 1.8rem);
      display: flex;
      flex-direction: column;
      gap: 1rem;
    }

    .player-panel {
      flex: 1 1 auto;
      min-width: 320px;
      max-width: 33.33%;
      position: relative;
    }

    @media (max-width: 960px) {
      .player-panel {
        max-width: 100%;
      }
    }

    .toolbox {
      flex: 1 1 100%;
      min-width: 260px;
      gap: 1rem;
    }

    .transcript-container {
      flex: 2 1 auto;
      min-width: 380px;
      max-width: 66.66%;
      display: flex;
      gap: 0.5rem;
      max-height: 76vh;
    }

    @media (max-width: 960px) {
      .transcript-container {
        max-width: 100%;
      }
    }

    .transcript-panel {
      flex: 1 1 auto;
      min-width: 320px;
      max-height: 76vh;
      gap: 1.2rem;
    }

    .transcript-toolbox {
      flex: 0 0 auto;
      width: 56px;
      max-height: 76vh;
      display: flex;
      flex-direction: column;
      gap: 0.6rem;
      padding: 0.75rem 0.4rem;
      background: var(--panel);
      border: 1px solid var(--panel-border);
      border-radius: 18px;
    }

    .toolbox-btn {
      border: 1px solid rgba(148, 163, 184, 0.24);
      background: rgba(148, 163, 184, 0.14);
      border-radius: 12px;
      padding: 0.6rem 0.3rem;
      color: var(--text);
      cursor: pointer;
      font-size: 1.5rem;
      font-family: Inter, sans-serif;
      transition: all 0.2s ease;
      white-space: nowrap;
      text-align: center;
      line-height: 1.2;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .toolbox-btn:hover {
      background: rgba(56, 189, 248, 0.18);
      border-color: rgba(56, 189, 248, 0.4);
    }

    .toolbox-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .transcript-scroll {
      display: flex;
      flex-direction: column;
      gap: 1rem;
      overflow-y: auto;
      padding-right: 0.4rem;
      line-height: 1.6;
      color: var(--text);
      max-height: calc(76vh - 4rem);
    }

    .transcript-entry {
      display: flex;
      flex-direction: column;
      gap: 0.45rem;
      max-width: 70%;
      padding: 0.75rem 1rem;
      border-radius: 16px;
      background: rgba(148, 163, 184, 0.28);
      box-shadow: 0 12px 24px rgba(15, 23, 42, 0.24);
      border: 1px solid rgba(148, 163, 184, 0.15);
    }

    .transcript-entry p {
      margin: 0;
      color: #f8fafc;
      font-size: 0.94rem;
      line-height: 1.6;
    }

    .transcript-entry .transcript-meta {
      font-size: 0.76rem;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      color: #cbd5e1;
    }

    .transcript-entry time {
      font-size: inherit;
      color: inherit;
      background: transparent;
      padding: 0;
      margin: 0;
    }

    .transcript-entry.speaker-interviewer {
      background: rgba(56, 189, 248, 0.35);
      border-color: rgba(56, 189, 248, 0.25);
      align-self: flex-start;
    }

    .transcript-entry.speaker-guest {
      background: rgba(74, 222, 128, 0.35);
      border-color: rgba(74, 222, 128, 0.25);
      align-self: flex-end;
    }

    .transcript-entry.speaker-guest .transcript-meta {
      text-align: right;
    }

    .transcript-entry.speaker-guest p {
      text-align: left;
    }

    .transcript-entry.speaker-narration {
      background: rgba(148, 163, 184, 0.28);
      border-color: rgba(148, 163, 184, 0.15);
      align-self: center;
    }

    .transcript-entry.speaker-other {
      background: rgba(148, 163, 184, 0.28);
      border-color: rgba(148, 163, 184, 0.15);
    }

    /* Word-level editing styles */
    .transcript-entry .word {
      display: inline;
      padding: 2px 1px;
      cursor: pointer;
      transition: all 0.15s ease;
      border-radius: 3px;
      user-select: none;
    }

    .transcript-entry .word:hover {
      background: rgba(148, 163, 184, 0.5);
    }

    .transcript-entry .word.active {
      background: #3b82f6;
      color: white;
      padding: 3px 5px;
      font-weight: 500;
      box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.4);
    }

    .transcript-entry .word.selected {
      background: #a855f7;
      color: white;
      padding: 3px 5px;
      font-weight: 500;
      box-shadow: 0 0 0 2px rgba(168, 85, 247, 0.4);
    }

    .transcript-entry .word.deleted {
      text-decoration: line-through;
      opacity: 0.65;
      color: #fca5a5;
      background: rgba(239, 68, 68, 0.15);
    }

    .transcript-scroll.selecting .transcript-entry .word {
      cursor: text;
    }

    /* Edit controls styling */
    .edit-controls {
      display: flex;
      gap: 8px;
      align-items: center;
      padding: 12px;
      background: rgba(30, 41, 59, 0.6);
      border-radius: 12px;
      backdrop-filter: blur(8px);
      border: 1px solid rgba(148, 163, 184, 0.2);
    }

    .edit-controls label {
      display: flex;
      align-items: center;
      gap: 6px;
      font-size: 13px;
      color: var(--muted);
      cursor: pointer;
      user-select: none;
    }

    .edit-controls input[type="checkbox"] {
      cursor: pointer;
    }

    .edit-controls .btn-select {
      padding: 6px 10px;
      background: transparent;
      border: 1px solid rgba(148, 163, 184, 0.3);
      border-radius: 6px;
      color: var(--muted);
      font-size: 16px;
      cursor: pointer;
      transition: all 0.2s;
    }

    .edit-controls .btn-select:hover {
      background: rgba(59, 130, 246, 0.1);
      border-color: #3b82f6;
      color: #3b82f6;
    }

    .edit-controls .btn-select.active {
      background: rgba(59, 130, 246, 0.2);
      border-color: #3b82f6;
      color: #3b82f6;
      font-weight: 600;
    }

    .edit-controls .btn-icon {
      padding: 6px 10px;
      background: transparent;
      border: 1px solid rgba(148, 163, 184, 0.3);
      border-radius: 6px;
      color: var(--muted);
      font-size: 16px;
      cursor: pointer;
      transition: all 0.2s;
    }

    .edit-controls .btn-icon:hover {
      background: rgba(239, 68, 68, 0.1);
      border-color: #ef4444;
      color: #ef4444;
    }

    .edit-controls .btn-icon:disabled {
      opacity: 0.3;
      cursor: not-allowed;
    }

    .edit-controls .btn-restore {
      padding: 6px 12px;
      background: transparent;
      border: 1px solid rgba(148, 163, 184, 0.3);
      border-radius: 6px;
      color: var(--muted);
      font-size: 13px;
      cursor: pointer;
      transition: all 0.2s;
    }

    .edit-controls .btn-restore:hover {
      background: rgba(34, 197, 94, 0.1);
      border-color: #22c55e;
      color: #22c55e;
    }

    .edit-controls .btn-skip {
      padding: 6px 12px;
      background: transparent;
      border: 1px solid rgba(251, 191, 36, 0.3);
      border-radius: 6px;
      color: #fbbf24;
      font-size: 13px;
      cursor: pointer;
      transition: all 0.2s;
      font-weight: 500;
    }

    .edit-controls .btn-skip:hover {
      background: rgba(251, 191, 36, 0.1);
      border-color: #fbbf24;
      color: #fcd34d;
    }

    .edit-controls .btn-skip:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .edit-controls .btn-save {
      padding: 6px 12px;
      background: rgba(168, 85, 247, 0.1);
      border: 1px solid rgba(168, 85, 247, 0.3);
      border-radius: 6px;
      color: #a855f7;
      font-size: 13px;
      cursor: pointer;
      transition: all 0.2s;
      font-weight: 500;
    }

    .edit-controls .btn-save:hover {
      background: rgba(168, 85, 247, 0.2);
      border-color: #a855f7;
      color: #d8b4fe;
    }

    .edit-controls .btn-save:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .edit-controls .stats {
      font-size: 12px;
      color: var(--muted);
      margin-left: auto;
    }

    video {
      width: 100%;
      border-radius: 16px;
      background: #020617;
      box-shadow: 0 18px 44px rgba(15, 23, 42, 0.4);
    }

    .loader-overlay {
      position: absolute;
      inset: 1.5rem 1.5rem auto;
      background: rgba(15, 23, 42, 0.94);
      border: 1px solid rgba(148, 163, 184, 0.22);
      border-radius: 18px;
      padding: 1rem 1.2rem;
      display: flex;
      flex-direction: column;
      gap: 0.65rem;
      box-shadow: 0 24px 64px rgba(15, 23, 42, 0.5);
      z-index: 5;
    }

    .loader-overlay.hidden {
      display: none;
    }

    .loader-title {
      margin: 0;
      font-size: 0.9rem;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      color: var(--muted);
    }

    .loader-bar {
      height: 6px;
      border-radius: 999px;
      background: rgba(148, 163, 184, 0.2);
      overflow: hidden;
    }

    .loader-bar__fill {
      height: 100%;
      width: 0;
      border-radius: inherit;
      background: linear-gradient(90deg, var(--accent), #0ea5e9);
      transition: width 0.18s ease;
    }

    .loader-text {
      margin: 0;
      font-size: 0.85rem;
      color: var(--muted);
    }

    .media-meta {
      display: flex;
      justify-content: space-between;
      font-size: 0.86rem;
      color: var(--muted);
      align-items: center;
    }

    .transcript-header {
      display: flex;
      justify-content: space-between;
      align-items: baseline;
      gap: 1rem;
    }

    .transcript-header h2 {
      margin: 0;
      font-size: 1rem;
      text-transform: uppercase;
      letter-spacing: 0.12em;
      color: var(--muted);
    }

    .status-badge {
      font-size: 0.75rem;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: var(--accent);
      border: 1px solid var(--accent);
      border-radius: 999px;
      padding: 0.25rem 0.75rem;
    }


    .version-toggle {
      position: absolute;
      top: 0.75rem;
      right: 0.75rem;
      display: inline-flex;
      background: rgba(15, 23, 42, 0.85);
      backdrop-filter: blur(8px);
      border-radius: 6px;
      padding: 0.25rem;
      gap: 0.25rem;
      z-index: 10;
      border: 1px solid rgba(148, 163, 184, 0.2);
    }

    .version-toggle button {
      border: none;
      border-radius: 4px;
      padding: 0.35rem 0.65rem;
      background: transparent;
      color: var(--muted);
      font-size: 0.7rem;
      letter-spacing: 0.05em;
      text-transform: uppercase;
      cursor: pointer;
      transition: all 0.2s ease;
      font-weight: 500;
    }

    .version-toggle button:hover {
      background: rgba(148, 163, 184, 0.25);
      color: rgba(241, 245, 249, 0.95);
    }

    .version-toggle button.active {
      background: var(--accent);
      color: #0b1120;
      font-weight: 600;
      box-shadow: 0 2px 8px rgba(56, 189, 248, 0.3);
    }

    .version-toggle button.pending {
      opacity: 0.75;
    }

    .version-toggle button:disabled {
      opacity: 0.45;
      cursor: wait;
    }

    .speed-selector {
      position: absolute;
      top: 0.75rem;
      left: 0.75rem;
      display: inline-flex;
      background: rgba(15, 23, 42, 0.85);
      backdrop-filter: blur(8px);
      border-radius: 6px;
      padding: 0.25rem;
      gap: 0.25rem;
      z-index: 10;
      border: 1px solid rgba(148, 163, 184, 0.2);
    }

    .speed-selector button {
      border: none;
      border-radius: 4px;
      padding: 0.35rem 0.5rem;
      background: transparent;
      color: var(--muted);
      font-size: 0.7rem;
      letter-spacing: 0.02em;
      cursor: pointer;
      transition: all 0.2s ease;
      font-weight: 500;
      min-width: 38px;
    }

    .speed-selector button:hover {
      background: rgba(148, 163, 184, 0.25);
      color: rgba(241, 245, 249, 0.95);
    }

    .speed-selector button.active {
      background: var(--accent);
      color: #0b1120;
      font-weight: 600;
      box-shadow: 0 2px 8px rgba(56, 189, 248, 0.3);
    }

    .status {
      color: var(--muted);
      font-size: 0.9rem;
    }

    .word {
      cursor: pointer;
      transition: background 0.16s ease, color 0.16s ease;
      border-radius: 6px;
      padding: 0 0.18rem;
      margin: 0 -0.05rem;
    }

    .word:hover {
      background: rgba(148, 163, 184, 0.2);
    }

    .word.active {
      background: rgba(56, 189, 248, 0.28);
      color: var(--text);
      box-shadow: 0 0 0 1px rgba(56, 189, 248, 0.4);
    }

    .links,
    .toolbox-header {
      display: flex;
      gap: 0.75rem;
      flex-wrap: wrap;
      align-items: center;
    }

    .links a,
    .toolbox-refresh {
      border: 1px solid rgba(148, 163, 184, 0.3);
      border-radius: 999px;
      padding: 0.45rem 1rem;
      text-decoration: none;
      color: var(--text);
      font-size: 0.85rem;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      transition: background 0.2s ease, border 0.2s ease;
    }

    .links a:hover,
    .toolbox-refresh:hover {
      background: rgba(56, 189, 248, 0.22);
      border-color: rgba(56, 189, 248, 0.4);
    }

    .toolbox-refresh {
      background: rgba(15, 23, 42, 0.5);
      cursor: pointer;
      line-height: 1;
    }

    .tool-list {
      display: flex;
      flex-direction: column;
      gap: 1rem;
    }

    .category-box {
      border: 1px solid rgba(148, 163, 184, 0.2);
      border-radius: 12px;
      overflow: hidden;
      background: rgba(148, 163, 184, 0.05);
    }

    .category-header {
      background: rgba(148, 163, 184, 0.1);
      padding: 0.75rem 1rem;
      display: flex;
      justify-content: space-between;
      align-items: center;
      border-bottom: 1px solid rgba(148, 163, 184, 0.15);
    }

    .category-title {
      font-size: 0.85rem;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: var(--text);
      margin: 0;
    }

    .category-play-btn {
      background: rgba(56, 189, 248, 0.2);
      border: 1px solid rgba(56, 189, 248, 0.4);
      border-radius: 8px;
      padding: 0.4rem 0.8rem;
      color: var(--text);
      cursor: pointer;
      font-size: 0.8rem;
      font-weight: 500;
      transition: all 0.2s ease;
      display: flex;
      align-items: center;
      gap: 0.4rem;
    }

    .category-play-btn:hover {
      background: rgba(56, 189, 248, 0.3);
      border-color: rgba(56, 189, 248, 0.6);
    }

    .category-play-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .category-scripts {
      padding: 0.8rem;
      display: flex;
      flex-direction: column;
      gap: 0.6rem;
    }

    .tool-button {
      border: 1px solid rgba(148, 163, 184, 0.24);
      background: rgba(148, 163, 184, 0.14);
      border-radius: 14px;
      padding: 0.55rem 0.8rem;
      color: var(--text);
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 0.6rem;
      cursor: pointer;
      transition: background 0.2s ease, border 0.2s ease;
      font-size: 0.88rem;
    }

    .tool-button:hover {
      background: rgba(56, 189, 248, 0.18);
      border-color: rgba(56, 189, 248, 0.4);
    }

    .tool-button .status {
      font-size: 0.78rem;
      color: rgba(148, 163, 184, 0.9);
    }

    .tool-button.completed {
      border-color: rgba(74, 222, 128, 0.45);
      background: rgba(74, 222, 128, 0.16);
    }

    .tool-button.completed .status::before {
      content: "‚úî ";
      color: #4ade80;
    }

    .tool-button.failed {
      border-color: rgba(248, 113, 113, 0.45);
      background: rgba(248, 113, 113, 0.16);
    }

    .tool-button.failed .status::before {
      content: "‚ö† ";
      color: #f87171;
    }

    .tool-button.pending {
      border-color: rgba(248, 113, 113, 0.45);
      background: rgba(248, 113, 113, 0.16);
    }

    .tool-entry {
      display: flex;
      flex-direction: column;
      gap: 0.35rem;
    }

    .cover-preview-button {
      align-self: flex-start;
      display: inline-flex;
      align-items: center;
      gap: 0.4rem;
      padding: 0.4rem 0.65rem;
      border-radius: 10px;
      border: 1px solid rgba(148, 163, 184, 0.26);
      background: rgba(148, 163, 184, 0.12);
      color: var(--text);
      font-size: 0.78rem;
      letter-spacing: 0.04em;
      text-transform: uppercase;
      cursor: pointer;
      transition: background 0.2s ease, border 0.2s ease, transform 0.18s ease;
    }

    .cover-preview-button:hover {
      background: rgba(56, 189, 248, 0.2);
      border-color: rgba(56, 189, 248, 0.4);
      transform: translateY(-1px);
    }

    .cover-preview-button svg {
      width: 18px;
      height: 18px;
      fill: currentColor;
    }

    .cover-modal.hidden {
      display: none;
    }

    .cover-modal {
      position: fixed;
      inset: 0;
      z-index: 3200;
      background: rgba(15, 23, 42, 0.76);
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 1.5rem;
    }

    .cover-modal-dialog {
      width: min(720px, 96vw);
      background: rgba(15, 23, 42, 0.92);
      border: 1px solid rgba(148, 163, 184, 0.25);
      border-radius: 20px;
      display: flex;
      flex-direction: column;
      gap: 1rem;
      padding: 1.2rem;
      box-shadow: 0 30px 80px rgba(15, 23, 42, 0.6);
    }

    .cover-modal-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 0.8rem;
    }

    .cover-modal-header h2 {
      margin: 0;
      font-size: 1rem;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      color: var(--muted);
    }

    .cover-modal-body {
      display: grid;
      gap: 1rem;
      grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
    }

    .cover-card {
      background: rgba(15, 23, 42, 0.72);
      border: 1px solid rgba(148, 163, 184, 0.2);
      border-radius: 16px;
      padding: 0.75rem;
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
    }

    .cover-card h3 {
      margin: 0;
      font-size: 0.85rem;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: var(--muted);
    }

    .cover-card img {
      width: 100%;
      border-radius: 12px;
      border: 1px solid rgba(148, 163, 184, 0.18);
      box-shadow: 0 10px 26px rgba(15, 23, 42, 0.45);
    }

    .cover-card footer {
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-size: 0.75rem;
      color: var(--muted);
    }

    .cover-card footer button {
      border: 1px solid rgba(148, 163, 184, 0.3);
      background: rgba(148, 163, 184, 0.16);
      color: var(--text);
      border-radius: 8px;
      padding: 0.35rem 0.6rem;
      font-size: 0.72rem;
      letter-spacing: 0.04em;
      text-transform: uppercase;
      cursor: pointer;
      transition: background 0.2s ease, border 0.2s ease;
    }

    .cover-card footer button:hover {
      background: rgba(56, 189, 248, 0.22);
      border-color: rgba(56, 189, 248, 0.4);
    }

    .tool-output {
      font-size: 0.78rem;
      color: var(--muted);
      margin-left: 0.25rem;
    }

    .job-list {
      display: flex;
      flex-direction: column;
      gap: 0.6rem;
      max-height: 220px;
      overflow-y: auto;
      padding-right: 0.3rem;
    }

    .job-item {
      background: rgba(15, 23, 42, 0.75);
      border: 1px solid rgba(148, 163, 184, 0.22);
      border-radius: 14px;
      padding: 0.65rem 0.8rem;
      display: flex;
      flex-direction: column;
      gap: 0.45rem;
    }

    .job-item h3 {
      margin: 0;
      font-size: 0.9rem;
      color: rgba(241, 245, 249, 0.88);
    }

    .job-status {
      font-size: 0.78rem;
      color: var(--muted);
    }

    .job-progress {
      height: 4px;
      border-radius: 999px;
      background: rgba(148, 163, 184, 0.22);
      overflow: hidden;
    }

    .job-progress span {
      display: block;
      height: 100%;
      width: 0;
      background: linear-gradient(90deg, var(--accent), #0ea5e9);
      transition: width 0.2s ease;
    }

    .file-modal.hidden {
      display: none;
    }

    .file-modal {
      position: fixed;
      inset: 0;
      background: rgba(15, 23, 42, 0.72);
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 1.5rem;
      z-index: 3000;
    }

    .file-modal-dialog {
      background: rgba(15, 23, 42, 0.92);
      border: 1px solid rgba(148, 163, 184, 0.25);
      border-radius: 18px;
      width: min(780px, 95vw);
      max-height: 90vh;
      display: flex;
      flex-direction: column;
      box-shadow: 0 24px 60px rgba(15, 23, 42, 0.55);
      overflow: hidden;
    }

    .file-modal-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 1rem 1.25rem 0.75rem;
      border-bottom: 1px solid rgba(148, 163, 184, 0.18);
      gap: 1rem;
    }

    .file-modal-header h2 {
      margin: 0;
      font-size: 1rem;
      letter-spacing: 0.08em;
      text-transform: uppercase;
    }

    .file-modal-path {
      margin: 0.2rem 0 0;
      font-size: 0.8rem;
      color: var(--muted);
    }

    .file-modal-body {
      padding: 1rem 1.25rem 1.25rem;
      display: flex;
      flex-direction: column;
      gap: 0.9rem;
      overflow: hidden;
    }

    .file-toolbar {
      display: flex;
      flex-wrap: wrap;
      gap: 0.6rem;
      align-items: center;
    }

    .file-toolbar button {
      border: 1px solid rgba(148, 163, 184, 0.3);
      background: rgba(148, 163, 184, 0.18);
      color: var(--text);
      font-size: 0.8rem;
      padding: 0.45rem 0.85rem;
      border-radius: 10px;
      cursor: pointer;
      transition: background 0.2s ease;
    }

    .file-toolbar button:hover:not(:disabled) {
      background: rgba(56, 189, 248, 0.26);
    }

    .file-toolbar button:disabled {
      opacity: 0.6;
      cursor: default;
    }

    .file-toolbar label {
      border: 1px solid rgba(148, 163, 184, 0.3);
      border-radius: 10px;
      padding: 0.45rem 0.85rem;
      color: var(--text);
      font-size: 0.8rem;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      background: rgba(148, 163, 184, 0.18);
      cursor: pointer;
      transition: background 0.2s ease;
      display: inline-flex;
      align-items: center;
      gap: 0.35rem;
    }

    .file-toolbar label:hover {
      background: rgba(56, 189, 248, 0.26);
    }

    #file-upload-input {
      display: none;
    }

    .file-selection-count {
      font-size: 0.78rem;
      color: var(--muted);
    }

    .file-breadcrumbs {
      display: flex;
      flex-wrap: wrap;
      gap: 0.35rem;
      font-size: 0.78rem;
      color: var(--muted);
    }

    .file-breadcrumbs button {
      border: none;
      background: transparent;
      color: inherit;
      font: inherit;
      cursor: pointer;
      padding: 0.1rem 0.35rem;
      border-radius: 6px;
      transition: background 0.2s ease;
    }

    .file-breadcrumbs button:hover {
      background: rgba(148, 163, 184, 0.18);
      color: var(--text);
    }

    .file-list {
      border: 1px solid rgba(148, 163, 184, 0.22);
      border-radius: 14px;
      background: rgba(15, 23, 42, 0.6);
      overflow: hidden;
      display: flex;
      flex-direction: column;
      max-height: 45vh;
    }

    .file-header,
    .file-row {
      display: grid;
      grid-template-columns: 32px 1fr 90px 130px 120px;
      gap: 0.6rem;
      align-items: center;
      padding: 0.55rem 0.85rem;
    }

    .file-header {
      font-size: 0.74rem;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      color: var(--muted);
      border-bottom: 1px solid rgba(148, 163, 184, 0.18);
    }

    .file-rows {
      overflow: auto;
    }

    .file-row {
      border-bottom: 1px solid rgba(148, 163, 184, 0.12);
      font-size: 0.85rem;
      transition: background 0.15s ease;
    }

    .file-row:last-child {
      border-bottom: none;
    }

    .file-row.selected {
      background: rgba(56, 189, 248, 0.16);
    }

    .file-row.directory .file-name {
      color: var(--text);
    }

    .file-name {
      border: none;
      background: transparent;
      color: var(--muted);
      font: inherit;
      text-align: left;
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      gap: 0.45rem;
    }

    .file-name:hover {
      color: var(--text);
    }

    .file-name svg {
      width: 18px;
      height: 18px;
      fill: currentColor;
    }

    .file-actions {
      display: inline-flex;
      gap: 0.35rem;
    }

    .file-actions button {
      border: 1px solid rgba(148, 163, 184, 0.25);
      background: rgba(148, 163, 184, 0.12);
      color: var(--text);
      font-size: 0.72rem;
      padding: 0.35rem 0.6rem;
      border-radius: 8px;
      cursor: pointer;
      transition: background 0.2s ease;
    }

    .file-actions button:hover:not(:disabled) {
      background: rgba(56, 189, 248, 0.22);
    }

    .file-actions button:disabled {
      opacity: 0.55;
      cursor: default;
    }

    .file-row input[type="checkbox"] {
      width: 16px;
      height: 16px;
      cursor: pointer;
    }

    .file-status {
      font-size: 0.78rem;
      color: var(--muted);
      margin: 0;
    }

    .file-empty-message {
      padding: 1.2rem;
      text-align: center;
      color: var(--muted);
      font-size: 0.85rem;
    }

    @media (min-width: 961px) {
      .tool-list, .job-list {
        flex-direction: row;
        flex-wrap: wrap;
      }
    }

    @media (max-width: 960px) {
      .toolbox {
        flex: 1 1 100%;
      }
      .transcript-panel {
        max-height: none;
      }
      .transcript-scroll {
        max-height: none;
      }
      .tool-list, .job-list {
        flex-direction: column;
      }
    }

    /* Bottom Log Bar */
    .log-bar {
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      background: var(--panel);
      border-top: 1px solid var(--panel-border);
      backdrop-filter: blur(12px);
      z-index: 1000;
      transition: transform 0.3s ease, height 0.3s ease;
    }

    .log-bar.minimized {
      transform: translateY(calc(100% - 42px));
    }

    .log-bar.hidden {
      transform: translateY(100%);
    }

    .log-bar-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 0.6rem 1.5rem;
      cursor: pointer;
      user-select: none;
      border-bottom: 1px solid transparent;
    }

    .log-bar:not(.minimized) .log-bar-header {
      border-bottom-color: var(--panel-border);
    }

    .log-bar-header:hover {
      background: rgba(148, 163, 184, 0.08);
    }

    .log-bar-title {
      display: flex;
      align-items: center;
      gap: 0.75rem;
      font-size: 0.85rem;
      font-weight: 600;
      letter-spacing: 0.05em;
      text-transform: uppercase;
      color: var(--muted);
    }

    .log-bar-toggle {
      transition: transform 0.3s ease;
      color: var(--muted);
    }

    .log-bar:not(.minimized) .log-bar-toggle {
      transform: rotate(180deg);
    }

    .log-bar-summary {
      display: flex;
      align-items: center;
      gap: 1rem;
      font-size: 0.8rem;
      color: var(--muted);
    }

    .log-bar-badge {
      background: rgba(56, 189, 248, 0.2);
      border: 1px solid rgba(56, 189, 248, 0.35);
      padding: 0.15rem 0.5rem;
      border-radius: 12px;
      font-size: 0.75rem;
      font-weight: 600;
    }

    .log-bar-badge.running {
      background: rgba(56, 189, 248, 0.2);
      border-color: rgba(56, 189, 248, 0.35);
      color: var(--accent);
    }

    .log-bar-badge.completed {
      background: rgba(52, 211, 153, 0.2);
      border-color: rgba(52, 211, 153, 0.35);
      color: #34d399;
    }

    .log-bar-badge.failed {
      background: rgba(248, 113, 113, 0.2);
      border-color: rgba(248, 113, 113, 0.35);
      color: #f87171;
    }

    .log-bar-content {
      max-height: 400px;
      overflow-y: auto;
      padding: 1rem 1.5rem;
      display: none;
    }

    .log-bar:not(.minimized) .log-bar-content {
      display: block;
    }

    .log-job-list {
      display: flex;
      flex-direction: column;
      gap: 1rem;
    }

    .log-job-card {
      background: rgba(15, 23, 42, 0.6);
      border: 1px solid var(--panel-border);
      border-radius: 12px;
      padding: 0.75rem 1rem;
    }

    .log-job-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 0.5rem;
    }

    .log-job-title {
      font-size: 0.9rem;
      font-weight: 600;
      color: var(--text);
    }

    .log-job-status {
      font-size: 0.8rem;
      color: var(--muted);
    }

    .log-job-progress {
      height: 4px;
      background: rgba(148, 163, 184, 0.2);
      border-radius: 4px;
      overflow: hidden;
      margin-bottom: 0.5rem;
    }

    .log-job-progress-fill {
      height: 100%;
      background: var(--accent);
      transition: width 0.3s ease;
    }

    .log-job-progress-fill.completed {
      background: #34d399;
    }

    .log-job-progress-fill.failed {
      background: #f87171;
    }

    .log-job-logs {
      background: rgba(0, 0, 0, 0.3);
      border: 1px solid rgba(148, 163, 184, 0.15);
      border-radius: 8px;
      padding: 0.6rem 0.75rem;
      max-height: 200px;
      overflow-y: auto;
      font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
      font-size: 0.75rem;
      line-height: 1.5;
      color: #94a3b8;
      display: none;
    }

    .log-job-logs.visible {
      display: block;
      margin-top: 0.5rem;
    }

    .log-job-log-line {
      margin: 0.2rem 0;
      word-wrap: break-word;
    }

    .log-job-actions {
      display: flex;
      gap: 0.5rem;
      margin-top: 0.5rem;
    }

    .log-job-action-btn {
      background: rgba(148, 163, 184, 0.15);
      border: 1px solid rgba(148, 163, 184, 0.25);
      color: var(--text);
      padding: 0.3rem 0.6rem;
      border-radius: 6px;
      font-size: 0.75rem;
      cursor: pointer;
      transition: background 0.2s ease;
    }

    .log-job-action-btn:hover {
      background: rgba(148, 163, 184, 0.25);
    }

    .log-bar-actions {
      display: flex;
      gap: 0.5rem;
    }

    .log-bar-action-btn {
      background: transparent;
      border: none;
      color: var(--muted);
      padding: 0.25rem;
      cursor: pointer;
      transition: color 0.2s ease;
      font-size: 1.2rem;
      line-height: 1;
    }

    .log-bar-action-btn:hover {
      color: var(--text);
    }

    body {
      padding-bottom: 42px; /* Space for minimized log bar */
    }
  </style>
</head>
<body>
  <header>
    <div class="brand-row">
      <img src="logo.svg" alt="Podfree" class="site-logo" />
      <div class="brand-actions">
        <nav class="top-nav">
          <a class="nav-link" href="projects.html">Projects</a>
          <a class="nav-link workspace-required active" href="editor.html">‚Ü≥ Editor</a>
          <a class="nav-link workspace-required" href="notes_editor.html">‚Ü≥ Notes</a>
          <a class="nav-link" href="about.html">About</a>
          <a class="nav-link" href="#" id="logout-link">Logout</a>
        </nav>
        <button id="file-manager-button" class="icon-button with-label" type="button" title="Manage workspace files">
          <svg viewBox="0 0 24 24" aria-hidden="true">
            <path d="M4 6a2 2 0 0 1 2-2h4.172a2 2 0 0 1 1.414.586L12.828 6H18a2 2 0 0 1 2 2v9a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6Z" />
            <path d="M8 11h8v2H8z" fill="currentColor" />
          </svg>
          <span>Files</span>
        </button>
      </div>
    </div>
    <h1 id="page-title">Edit Project</h1>
    <form id="title-form" class="title-form">
      <label for="title-input">Title</label>
      <div class="title-row">
        <input id="title-input" type="text" placeholder="Title will appear here" disabled />
        <button id="title-save" type="submit" disabled>Save</button>
        <span id="title-status" class="title-status">Idle</span>
      </div>
    </form>
    <form id="participant-form" class="participant-form">
      <label for="interviewer-input">Participants</label>
      <div class="participant-row">
        <div class="participant-field">
          <select id="interviewer-speaker-select" class="speaker-select" disabled>
            <option value="null">No Speaker ID</option>
            <option value="0">Speaker 0</option>
            <option value="1">Speaker 1</option>
            <option value="2">Speaker 2</option>
            <option value="3">Speaker 3</option>
          </select>
          <input id="interviewer-input" type="text" placeholder="Interviewer name" disabled />
        </div>
        <div class="participant-field">
          <select id="guest-speaker-select" class="speaker-select" disabled>
            <option value="null">No Speaker ID</option>
            <option value="0">Speaker 0</option>
            <option value="1">Speaker 1</option>
            <option value="2">Speaker 2</option>
            <option value="3">Speaker 3</option>
          </select>
          <input id="guest-input" type="text" placeholder="Guest name" disabled />
        </div>
        <button id="participant-save" type="submit" disabled>Save</button>
        <span id="participant-status" class="participant-status">Open a project from Projects ‚Üí</span>
      </div>
    </form>
  </header>

  <main class="layout">
    <section class="panel player-panel">
      <video id="media" controls preload="metadata">
        <source id="media-source" type="video/mp4" />
        Your browser does not support HTML video.
      </video>
      <div id="conversion-loader" class="loader-overlay hidden">
        <p class="loader-title">Preparing lightweight copy‚Ä¶</p>
        <div class="loader-bar"><div id="loader-progress" class="loader-bar__fill"></div></div>
        <p id="loader-text" class="loader-text">Starting job‚Ä¶</p>
      </div>
      <div class="speed-selector" id="speed-selector">
        <button type="button" data-speed="1" class="active">1√ó</button>
        <button type="button" data-speed="1.2">1.2√ó</button>
        <button type="button" data-speed="1.5">1.5√ó</button>
        <button type="button" data-speed="2">2√ó</button>
      </div>
      <div class="version-toggle" id="version-toggle">
        <button type="button" data-role="original">HD</button>
        <button type="button" class="active" data-role="proxy">SD</button>
      </div>
    </section>
    <div class="transcript-container">
      <section class="panel transcript-panel">
        <div class="transcript-header">
          <h2>Transcript</h2>
          <span id="transcript-status" class="status-badge">Idle</span>
        </div>
        <div class="edit-controls">
          <button type="button" id="selection-mode-btn" class="btn-select" title="Toggle selection mode">üñ±Ô∏è</button>
          <button type="button" id="delete-selected-btn" class="btn-icon" title="Delete selected words" disabled style="color: red;">‚úï</button>
          <button type="button" id="restore-selected-btn" class="btn-restore" title="Restore selected deleted words" disabled>‚Üª</button>
          <button type="button" id="skip-deleted-btn" class="btn-skip" title="Skip to next non-deleted word">‚è≠ Skip Deleted</button>
          <span id="word-stats" class="stats"></span>
        </div>
        <div id="transcript" class="transcript-scroll">
          <p>Open a project with a transcript to preview it here.</p>
        </div>
      </section>
      <aside class="transcript-toolbox">
        <button type="button" id="save-edits-btn" class="toolbox-btn" title="Save edits">üíæ</button>
        <button type="button" id="export-video-btn" class="toolbox-btn" title="Render edited video">üé¨</button>
        <button type="button" id="export-audio-btn" class="toolbox-btn" title="Render edited audio">üéôÔ∏è</button>
      </aside>
    </div>
    <aside class="panel toolbox">
      <div class="toolbox-header">
        <h2 style="margin:0;font-size:0.9rem;text-transform:uppercase;letter-spacing:0.12em;color:var(--muted);">
          Toolbox
        </h2>
        <button id="refresh-scripts" class="toolbox-refresh" type="button">‚Ü∫</button>
      </div>
      <div id="tool-list" class="tool-list"></div>
      <div id="job-list" class="job-list"></div>
    </aside>
  </main>

  <!-- Bottom Log Bar -->
  <div id="log-bar" class="log-bar minimized">
    <div class="log-bar-header" id="log-bar-toggle">
      <div class="log-bar-title">
        <span>Activity</span>
        <div class="log-bar-summary" id="log-bar-summary">
          <span id="log-summary-text">No active jobs</span>
        </div>
      </div>
      <div style="display: flex; align-items: center; gap: 0.75rem;">
        <div class="log-bar-actions">
          <button class="log-bar-action-btn" id="log-bar-clear" title="Clear completed jobs" style="font-size: 1rem;">√ó</button>
        </div>
        <span class="log-bar-toggle">‚ñº</span>
      </div>
    </div>
    <div class="log-bar-content">
      <div class="log-job-list" id="log-job-list"></div>
    </div>
  </div>

  <div id="file-manager-modal" class="file-modal hidden" role="dialog" aria-modal="true" aria-labelledby="file-manager-title">
    <div class="file-modal-dialog">
      <div class="file-modal-header">
        <div>
          <h2 id="file-manager-title">Workspace Files</h2>
          <p id="file-manager-path" class="file-modal-path"></p>
        </div>
        <button type="button" id="file-manager-close" class="icon-button small" aria-label="Close file manager">&times;</button>
      </div>
      <div class="file-modal-body">
        <div class="file-toolbar">
          <button type="button" id="file-download-selected" disabled>Download Selected</button>
          <button type="button" id="file-delete-selected" disabled>Delete Selected</button>
          <button type="button" id="file-download-all">Download Project (.zip)</button>
          <label for="file-upload-input">
            <svg viewBox="0 0 24 24" aria-hidden="true" style="width:16px;height:16px;fill:currentColor;"><path d="M5 20h14v-3h2v3a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-3h2v3Z" opacity="0.35"/><path d="M12 3a1 1 0 0 1 1 1v9.586l2.293-2.293a1 1 0 0 1 1.414 1.414l-4 4a1 1 0 0 1-1.414 0l-4-4a1 1 0 0 1 1.414-1.414L11 13.586V4a1 1 0 0 1 1-1Z"/></svg>
            Upload Files
          </label>
          <input id="file-upload-input" type="file" multiple />
          <span id="file-selection-count" class="file-selection-count">Select files to enable actions.</span>
        </div>
        <div id="file-breadcrumbs" class="file-breadcrumbs"></div>
        <div class="file-list">
          <div class="file-header">
            <span></span>
            <span>Name</span>
            <span>Size</span>
            <span>Modified</span>
            <span>Actions</span>
          </div>
          <div id="file-manager-rows" class="file-rows"></div>
        </div>
        <p id="file-manager-status" class="file-status"></p>
      </div>
    </div>
  </div>

  <div id="cover-preview-modal" class="cover-modal hidden" role="dialog" aria-modal="true" aria-labelledby="cover-preview-title">
    <div class="cover-modal-dialog">
      <div class="cover-modal-header">
        <h2 id="cover-preview-title">Covers</h2>
        <button type="button" id="cover-preview-close" class="icon-button small" aria-label="Close cover preview">&times;</button>
      </div>
      <div id="cover-preview-body" class="cover-modal-body"></div>
    </div>
  </div>

  <div id="media-preview-modal" class="file-modal hidden" role="dialog" aria-modal="true" aria-labelledby="media-preview-title">
    <div class="file-modal-dialog" style="max-width: 900px;">
      <div class="file-modal-header">
        <h2 id="media-preview-title">Media Preview</h2>
        <button type="button" id="media-preview-close" class="icon-button small" aria-label="Close media preview">&times;</button>
      </div>
      <div class="file-modal-body" style="padding: 0;">
        <div id="media-preview-body" style="display: flex; align-items: center; justify-content: center; background: #000; min-height: 400px;"></div>
      </div>
    </div>
  </div>

  <div id="unsaved-changes-modal" class="file-modal hidden" role="dialog" aria-modal="true" style="z-index: 10000;">
    <div class="file-modal-dialog" style="max-width: 400px;">
      <div class="file-modal-header">
        <h2>Unsaved Changes</h2>
      </div>
      <div class="file-modal-body" style="padding: 1.5rem;">
        <p style="margin: 0 0 1.5rem 0; color: var(--text);">You have unsaved transcript edits. What would you like to do?</p>
        <div style="display: flex; gap: 0.75rem; flex-direction: column;">
          <button type="button" id="unsaved-save-btn" class="btn-save" style="width: 100%; padding: 0.75rem;">üíæ Save and Continue</button>
          <button type="button" id="unsaved-discard-btn" style="width: 100%; padding: 0.75rem; background: rgba(239, 68, 68, 0.1); border: 1px solid rgba(239, 68, 68, 0.3); border-radius: 8px; color: #ef4444; cursor: pointer;">Don't Save</button>
          <button type="button" id="unsaved-cancel-btn" style="width: 100%; padding: 0.75rem; background: transparent; border: 1px solid rgba(148, 163, 184, 0.3); border-radius: 8px; color: var(--muted); cursor: pointer;">Cancel</button>
        </div>
      </div>
    </div>
  </div>

  <script>
    function redirectToLogin() {
      // Always redirect to Projects page after re-login, not back to Editor
      const next = encodeURIComponent('/projects.html');
      window.location.replace(`/login.html?next=${next}`);
    }

    const originalFetch = window.fetch;
    window.fetch = async (...args) => {
      const response = await originalFetch(...args);
      if (response.status === 401) {
        redirectToLogin();
        throw new Error('unauthorized');
      }
      return response;
    };

    async function handleLogout(event) {
      if (event) {
        event.preventDefault();
      }
      try {
        await fetch('/api/logout', { method: 'POST' });
      } catch (error) {
        console.error('Logout failed', error);
      } finally {
        window.location.replace('/login.html');
      }
    }

    const statusLine = document.getElementById('status-line');
    const media = document.getElementById('media');
    const mediaSource = document.getElementById('media-source');
    const conversionLoader = document.getElementById('conversion-loader');
    const loaderFill = document.getElementById('loader-progress');
    const loaderText = document.getElementById('loader-text');
    const currentTimeEl = document.getElementById('current-time');
    const durationEl = document.getElementById('duration');
    const versionToggle = document.getElementById('version-toggle');
    const originalButton = versionToggle ? versionToggle.querySelector('[data-role="original"]') : null;
    const proxyButton = versionToggle ? versionToggle.querySelector('[data-role="proxy"]') : null;
    const speedSelector = document.getElementById('speed-selector');
    const toolList = document.getElementById('tool-list');
    const jobList = document.getElementById('job-list');
    const refreshScriptsBtn = document.getElementById('refresh-scripts');
    const pageTitle = document.getElementById('page-title');
    const titleForm = document.getElementById('title-form');
    const titleInput = document.getElementById('title-input');
    const titleSave = document.getElementById('title-save');
    const titleStatus = document.getElementById('title-status');
    const participantForm = document.getElementById('participant-form');
    const interviewerInput = document.getElementById('interviewer-input');
    const guestInput = document.getElementById('guest-input');
    const interviewerSpeakerSelect = document.getElementById('interviewer-speaker-select');
    const guestSpeakerSelect = document.getElementById('guest-speaker-select');
    const participantSave = document.getElementById('participant-save');
    const participantStatus = document.getElementById('participant-status');
    const transcriptEl = document.getElementById('transcript');
    const transcriptStatus = document.getElementById('transcript-status');
    const participantInfo = document.getElementById('participant-info');
    const interviewerLabelEl = document.getElementById('interviewer-label');
    const guestLabelEl = document.getElementById('guest-label');
    const logoutLink = document.getElementById('logout-link');
    const fileManagerButton = document.getElementById('file-manager-button');
    const fileManagerModal = document.getElementById('file-manager-modal');

    // Edit controls
    const selectionModeBtn = document.getElementById('selection-mode-btn');
    const deleteSelectedBtn = document.getElementById('delete-selected-btn');
    const restoreSelectedBtn = document.getElementById('restore-selected-btn');
    const skipDeletedBtn = document.getElementById('skip-deleted-btn');
    const saveEditsBtn = document.getElementById('save-edits-btn');
    const exportVideoBtn = document.getElementById('export-video-btn');
    const exportAudioBtn = document.getElementById('export-audio-btn');
    const wordStatsEl = document.getElementById('word-stats');
    const unsavedChangesModal = document.getElementById('unsaved-changes-modal');
    const unsavedSaveBtn = document.getElementById('unsaved-save-btn');
    const unsavedDiscardBtn = document.getElementById('unsaved-discard-btn');
    const unsavedCancelBtn = document.getElementById('unsaved-cancel-btn');
    const fileManagerClose = document.getElementById('file-manager-close');
    const fileManagerRows = document.getElementById('file-manager-rows');
    const fileManagerStatus = document.getElementById('file-manager-status');
    const fileSelectionCount = document.getElementById('file-selection-count');
    const fileDownloadSelectedBtn = document.getElementById('file-download-selected');
    const fileDeleteSelectedBtn = document.getElementById('file-delete-selected');
    const fileDownloadAllBtn = document.getElementById('file-download-all');
    const fileBreadcrumbs = document.getElementById('file-breadcrumbs');
    const fileManagerPath = document.getElementById('file-manager-path');
    const coverPreviewModal = document.getElementById('cover-preview-modal');
    const coverPreviewClose = document.getElementById('cover-preview-close');
    const coverPreviewBody = document.getElementById('cover-preview-body');
    const mediaPreviewModal = document.getElementById('media-preview-modal');
    const mediaPreviewClose = document.getElementById('media-preview-close');
    const mediaPreviewBody = document.getElementById('media-preview-body');
    const mediaPreviewTitle = document.getElementById('media-preview-title');
    const fileUploadInput = document.getElementById('file-upload-input');

    let workspaceInfo = null;
    let workspaceProjectName = null;
    let workspaceFiles = { notes: null, srt: null, video: null, proxy: null, audio: null, transcript_json: null, chapters: null };
    let workspaceSources = { original: null, proxy: null };
    let currentSourceRole = 'proxy';
    let currentSpeed = 1.0;
    const scriptButtons = new Map();
    const scriptStateCache = { key: null, data: {} };
    let transcriptSource = { kind: null, name: null, url: null };
    let currentTranscriptSegments = [];
    let wordSpans = [];
    let activeWordIndex = -1;
    let selectionMode = false;
    let selectedWords = new Set();
    let deletedWords = new Set();
    let isDragging = false;
    let dragStartIndex = -1;
    let dragCurrentIndex = -1;
    let dragStartSegment = null;
    let hasUnsavedChanges = false;
    let savedDeletedWords = new Set();
    let videoExportCompleted = false;
    let audioExportCompleted = false;
    let playbackTrackingInterval = null;
    let isCurrentlySeeking = false;
    let userIsScrolling = false;
    let scrollTimeout = null;
    let lastNotesContent = null;
    let guestName = '';
    let interviewerName = '';
    let interviewerSpeakerId = 'null';  // Default to "No Speaker ID" for transcripts without diarization
    let guestSpeakerId = 'null';
    const fileManagerState = {
      currentDir: '.',
      entries: [],
      selected: new Set(),
      breadcrumbs: [],
    };
    let speakerMap = new Map();
    const SEEK_EPSILON = 0.2;
    const MERGE_GAP_SECONDS = 1.5;

    if (logoutLink) {
      logoutLink.addEventListener('click', handleLogout);
    }

    if (fileDownloadAllBtn) {
      fileDownloadAllBtn.disabled = true;
    }

    if (fileManagerButton) {
      fileManagerButton.addEventListener('click', () => openFileManager('.'));
    }

    if (fileManagerClose) {
      fileManagerClose.addEventListener('click', closeFileManager);
    }

    if (fileManagerModal) {
      fileManagerModal.addEventListener('click', (event) => {
        if (event.target === fileManagerModal) {
          closeFileManager();
        }
      });
    }

    if (coverPreviewModal) {
      coverPreviewModal.addEventListener('click', (event) => {
        if (event.target === coverPreviewModal) {
          closeCoverPreview();
        }
      });
    }

    if (coverPreviewClose) {
      coverPreviewClose.addEventListener('click', closeCoverPreview);
    }

    if (mediaPreviewClose) {
      mediaPreviewClose.addEventListener('click', closeMediaPreview);
    }

    if (fileDeleteSelectedBtn) {
      fileDeleteSelectedBtn.addEventListener('click', () => {
        deleteFiles(Array.from(fileManagerState.selected));
      });
    }

    if (fileDownloadSelectedBtn) {
      fileDownloadSelectedBtn.addEventListener('click', () => {
        downloadSelected(Array.from(fileManagerState.selected));
      });
    }

    if (fileDownloadAllBtn) {
      fileDownloadAllBtn.addEventListener('click', downloadProjectArchive);
    }

    async function uploadFilesToWorkspace(files) {
      if (!files || !files.length) return;
      if (!workspaceInfo || !workspaceInfo.path) {
        alert('Select a project before uploading files.');
        return;
      }

      // Create a unique job ID for this upload
      const uploadJobId = 'upload-' + Date.now();
      const fileNames = Array.from(files).map(f => f.name).join(', ');
      const fileCount = files.length;
      const label = `Upload ${fileCount} file${fileCount > 1 ? 's' : ''}: ${fileNames.length > 50 ? fileNames.substring(0, 50) + '...' : fileNames}`;

      try {
        // Create job card for upload
        addJobCard(uploadJobId, label);
        const jobData = activeJobs.get(uploadJobId);
        if (jobData) {
          jobData.status = 'running';
          jobData.statusEl.textContent = 'running ‚Äî preparing upload';
          jobData.progressFill.style.width = '0%';
          updateLogBarSummary();
        }

        const summary = await fetch('/api/workspace').then((resp) => resp.json());
        const projectName = summary && summary.project_name ? summary.project_name : null;
        const workspacePath = summary && summary.path ? summary.path : null;
        if (projectName) {
          await uploadViaProjectsEndpoint(projectName, files, uploadJobId);
          await loadWorkspace({ refresh: true });
          await refreshFileManager('.');

          // Mark as completed
          const jobData = activeJobs.get(uploadJobId);
          if (jobData) {
            jobData.status = 'completed';
            jobData.statusEl.textContent = 'completed ‚Äî files uploaded successfully';
            jobData.progressFill.style.width = '100%';
            jobData.progressFill.classList.add('completed');
            updateLogBarSummary();
          }
          return;
        }
        if (workspacePath) {
          await uploadViaWorkspaceEndpoint(workspacePath, files, uploadJobId);
          await loadWorkspace({ refresh: true });
          await refreshFileManager('.');

          // Mark as completed
          const jobData = activeJobs.get(uploadJobId);
          if (jobData) {
            jobData.status = 'completed';
            jobData.statusEl.textContent = 'completed ‚Äî files uploaded successfully';
            jobData.progressFill.style.width = '100%';
            jobData.progressFill.classList.add('completed');
            updateLogBarSummary();
          }
          return;
        }
        alert('Workspace path unavailable; cannot determine upload target.');
      } catch (error) {
        console.error(error);

        // Mark as failed
        const jobData = activeJobs.get(uploadJobId);
        if (jobData) {
          jobData.status = 'failed';
          jobData.statusEl.textContent = `failed ‚Äî ${error.message}`;
          jobData.progressFill.classList.add('failed');
          updateLogBarSummary();
        }

        alert('Upload failed: ' + error.message);
      }
    }

    function setFileUploadState(pending = false, message = 'Uploading‚Ä¶') {
      if (!fileManagerStatus) return;
      if (pending) {
        fileManagerStatus.textContent = message;
      } else {
        fileManagerStatus.textContent = '';
      }
    }

    function uploadViaProjectsEndpoint(projectName, files, uploadJobId) {
      return new Promise((resolve, reject) => {
        const formData = new FormData();
        Array.from(files).forEach((file) => formData.append('files', file));
        setFileUploadState(true, 'Uploading‚Ä¶');
        const xhr = new XMLHttpRequest();
        xhr.open('POST', `/api/projects/upload?project=${encodeURIComponent(projectName)}`);
        xhr.upload.onprogress = (event) => {
          if (!event.lengthComputable) return;
          const pct = Math.max(0, Math.min(100, Math.round((event.loaded / event.total) * 100)));
          setFileUploadState(true, `Uploading‚Ä¶ ${pct}%`);

          // Update log bar job progress
          const jobData = activeJobs.get(uploadJobId);
          if (jobData) {
            jobData.progressFill.style.width = `${pct}%`;
            jobData.statusEl.textContent = `running ‚Äî uploading ${pct}%`;
          }
        };
        xhr.onerror = () => {
          setFileUploadState(false);
          reject(new Error('Network error during upload.'));
        };
        xhr.onload = () => {
          setFileUploadState(false);
          if (xhr.status >= 200 && xhr.status < 300) {
            resolve(JSON.parse(xhr.responseText || '{}'));
          } else {
            reject(new Error(xhr.responseText || xhr.statusText));
          }
        };
        xhr.send(formData);
      });
    }

    function uploadViaWorkspaceEndpoint(workspacePath, files, uploadJobId) {
      return new Promise((resolve, reject) => {
        const formData = new FormData();
        Array.from(files).forEach((file) => formData.append('files', file));
        setFileUploadState(true, 'Uploading‚Ä¶');
        const xhr = new XMLHttpRequest();
        xhr.open('POST', '/api/workspace/upload');
        xhr.setRequestHeader('X-Workspace-Path', workspacePath);
        xhr.upload.onprogress = (event) => {
          if (!event.lengthComputable) return;
          const pct = Math.max(0, Math.min(100, Math.round((event.loaded / event.total) * 100)));
          setFileUploadState(true, `Uploading‚Ä¶ ${pct}%`);

          // Update log bar job progress
          const jobData = activeJobs.get(uploadJobId);
          if (jobData) {
            jobData.progressFill.style.width = `${pct}%`;
            jobData.statusEl.textContent = `running ‚Äî uploading ${pct}%`;
          }
        };
        xhr.onerror = () => {
          setFileUploadState(false);
          reject(new Error('Network error during upload.'));
        };
        xhr.onload = () => {
          setFileUploadState(false);
          if (xhr.status >= 200 && xhr.status < 300) {
            resolve(JSON.parse(xhr.responseText || '{}'));
          } else {
            reject(new Error(xhr.responseText || xhr.statusText));
          }
        };
        xhr.send(formData);
      });
    }

    if (fileUploadInput) {
      fileUploadInput.addEventListener('change', async (event) => {
        const input = event.target;
        if (!input.files || input.files.length === 0) return;
        const files = Array.from(input.files);
        input.value = '';
        await uploadFilesToWorkspace(files);
      });
    }

    // Reset drag selection on mouse up
    document.addEventListener('mouseup', () => {
      if (isDragging) {
        // If it was just a click (no drag), toggle the single word
        if (dragStartIndex === dragCurrentIndex && dragStartIndex >= 0) {
          toggleWordSelection(dragStartIndex);
        }
        isDragging = false;
        dragStartIndex = -1;
        dragCurrentIndex = -1;
        dragStartSegment = null;
      }
    });

    document.addEventListener('keydown', (event) => {
      // Word editing keyboard shortcuts
      if (!event.metaKey && !event.ctrlKey && !event.altKey) {
        // Space: toggle play/pause (when not in input field)
        if (event.key === ' ' && !['INPUT', 'TEXTAREA'].includes(event.target.tagName)) {
          event.preventDefault();
          if (media.paused) {
            media.play().catch(() => {});
          } else {
            media.pause();
          }
          return;
        }

        // Delete/Backspace: toggle delete word under cursor
        if ((event.key === 'Delete' || event.key === 'Backspace') && activeWordIndex >= 0 && !['INPUT', 'TEXTAREA'].includes(event.target.tagName)) {
          event.preventDefault();
          toggleWordDeleted(activeWordIndex);
          return;
        }

        // ArrowLeft/ArrowRight: navigate words
        if (event.key === 'ArrowLeft' && activeWordIndex > 0 && !['INPUT', 'TEXTAREA'].includes(event.target.tagName)) {
          event.preventDefault();
          // Re-enable auto-scroll when using arrow keys
          userIsScrolling = false;
          if (scrollTimeout) {
            clearTimeout(scrollTimeout);
            scrollTimeout = null;
          }
          const prevIndex = activeWordIndex - 1;
          media.currentTime = Math.max(0, wordSpans[prevIndex].start - SEEK_EPSILON);
          highlightWordByIndex(prevIndex);
          return;
        }
        if (event.key === 'ArrowRight' && activeWordIndex < wordSpans.length - 1 && !['INPUT', 'TEXTAREA'].includes(event.target.tagName)) {
          event.preventDefault();
          // Re-enable auto-scroll when using arrow keys
          userIsScrolling = false;
          if (scrollTimeout) {
            clearTimeout(scrollTimeout);
            scrollTimeout = null;
          }
          const nextIndex = activeWordIndex + 1;
          media.currentTime = Math.max(0, wordSpans[nextIndex].start - SEEK_EPSILON);
          highlightWordByIndex(nextIndex);
          return;
        }
      }

      // Escape key for modals
      if (event.key !== 'Escape') return;
      if (mediaPreviewModal && !mediaPreviewModal.classList.contains('hidden')) {
        closeMediaPreview();
        return;
      }
      if (coverPreviewModal && !coverPreviewModal.classList.contains('hidden')) {
        closeCoverPreview();
        return;
      }
      if (fileManagerModal && !fileManagerModal.classList.contains('hidden')) {
        closeFileManager();
      }
    });

    // Speaker dropdown auto-swap logic
    if (interviewerSpeakerSelect && guestSpeakerSelect) {
      interviewerSpeakerSelect.addEventListener('change', (event) => {
        const selectedValue = event.target.value;
        if (selectedValue === guestSpeakerSelect.value) {
          // Swap: if interviewer selects what guest has, swap them
          guestSpeakerSelect.value = interviewerSpeakerId === null ? 'null' : String(interviewerSpeakerId);
        }
        // Handle both numeric speaker IDs and 'null' for no speaker ID
        interviewerSpeakerId = selectedValue === 'null' ? null : parseInt(selectedValue, 10);
        const guestValue = guestSpeakerSelect.value;
        guestSpeakerId = guestValue === 'null' ? null : parseInt(guestValue, 10);
        // Rebuild speaker mapping with new assignments
        if (currentTranscriptSegments && currentTranscriptSegments.length > 0) {
          renderTranscript(currentTranscriptSegments);
        }
      });

      guestSpeakerSelect.addEventListener('change', (event) => {
        const selectedValue = event.target.value;
        if (selectedValue === interviewerSpeakerSelect.value) {
          // Swap: if guest selects what interviewer has, swap them
          interviewerSpeakerSelect.value = guestSpeakerId === null ? 'null' : String(guestSpeakerId);
        }
        // Handle both numeric speaker IDs and 'null' for no speaker ID
        guestSpeakerId = selectedValue === 'null' ? null : parseInt(selectedValue, 10);
        const interviewerValue = interviewerSpeakerSelect.value;
        interviewerSpeakerId = interviewerValue === 'null' ? null : parseInt(interviewerValue, 10);
        // Rebuild speaker mapping with new assignments
        if (currentTranscriptSegments && currentTranscriptSegments.length > 0) {
          renderTranscript(currentTranscriptSegments);
        }
      });
    }

    if (participantForm) {
      participantForm.addEventListener('submit', async (event) => {
        event.preventDefault();
        if (!participantSave || !interviewerInput || !guestInput) return;
        const nextInterviewer = interviewerInput.value.trim();
        const nextGuest = guestInput.value.trim();
        if (!lastNotesContent) {
          await loadNotesTitle();
          if (!lastNotesContent) {
            setParticipantFormState({ disabled: true, interviewer: nextInterviewer, guest: nextGuest, status: 'Notes unavailable' });
            return;
          }
        }
        setParticipantFormState({ disabled: true, interviewer: nextInterviewer, guest: nextGuest, status: 'Saving‚Ä¶' });
        try {
          let updated = replaceSectionFirstLine(lastNotesContent, '## Interviewer', nextInterviewer);
          updated = replaceSectionFirstLine(updated, '## Guest', nextGuest);
          const response = await fetch('/api/notes', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ content: updated }),
          });
          if (!response.ok) {
            throw new Error(await response.text());
          }
          await response.json();
          lastNotesContent = updated;
          interviewerName = nextInterviewer;
          guestName = nextGuest;
          // Save speaker IDs to localStorage
          if (workspaceProjectName) {
            const speakerMapping = {
              interviewerSpeakerId: interviewerSpeakerId,
              guestSpeakerId: guestSpeakerId
            };
            localStorage.setItem(`speaker-mapping-${workspaceProjectName}`, JSON.stringify(speakerMapping));
          }
          updateParticipantDisplay();
          // Rebuild speaker mapping with updated names
          if (currentTranscriptSegments && currentTranscriptSegments.length > 0) {
            renderTranscript(currentTranscriptSegments);
          }
          setParticipantFormState({ disabled: false, interviewer: nextInterviewer, guest: nextGuest, status: `Saved at ${new Date().toLocaleTimeString()}` });
        } catch (error) {
          console.error(error);
          alert('Unable to update participants: ' + error.message);
          setParticipantFormState({ disabled: false, interviewer: nextInterviewer, guest: nextGuest, status: 'Save failed' });
        }
      });
    }

    function updateBodyModalState() {
      const filesOpen = fileManagerModal && !fileManagerModal.classList.contains('hidden');
      const coversOpen = coverPreviewModal && !coverPreviewModal.classList.contains('hidden');
      const mediaOpen = mediaPreviewModal && !mediaPreviewModal.classList.contains('hidden');
      if (filesOpen || coversOpen || mediaOpen) {
        document.body.classList.add('modal-open');
      } else {
        document.body.classList.remove('modal-open');
      }
    }

    function updateParticipantDisplay() {
      if (interviewerLabelEl) {
        const nameEl = interviewerLabelEl.querySelector('.participant-name');
        if (nameEl) {
          nameEl.textContent = interviewerName || '‚Äî';
        } else {
          interviewerLabelEl.textContent = interviewerName ? `Interviewer: ${interviewerName}` : 'Interviewer: ‚Äî';
        }
        interviewerLabelEl.classList.toggle('missing', !interviewerName);
      }
      if (guestLabelEl) {
        const nameEl = guestLabelEl.querySelector('.participant-name');
        if (nameEl) {
          nameEl.textContent = guestName || '‚Äî';
        } else {
          guestLabelEl.textContent = guestName ? `Guest: ${guestName}` : 'Guest: ‚Äî';
        }
        guestLabelEl.classList.toggle('missing', !guestName);
      }
      if (participantInfo) {
        const hasNames = Boolean(guestName || interviewerName);
        participantInfo.classList.toggle('all-missing', !hasNames);
      }
      setParticipantFormState({
        disabled: participantSave ? participantSave.disabled : true,
        interviewer: interviewerName || '',
        guest: guestName || '',
        status: participantStatus ? participantStatus.textContent : undefined,
      });
    }

    function setParticipantFormState({ disabled = false, interviewer = null, guest = null, status } = {}) {
      const nextStatus = typeof status === 'string'
        ? status
        : (participantStatus ? participantStatus.textContent || 'Idle' : 'Idle');
      if (typeof interviewer === 'string' && interviewerInput) {
        interviewerInput.value = interviewer;
      }
      if (typeof guest === 'string' && guestInput) {
        guestInput.value = guest;
      }
      if (participantSave) {
        participantSave.disabled = disabled;
      }
      if (interviewerInput) {
        interviewerInput.disabled = disabled;
      }
      if (guestInput) {
        guestInput.disabled = disabled;
      }
      if (interviewerSpeakerSelect) {
        interviewerSpeakerSelect.disabled = disabled;
      }
      if (guestSpeakerSelect) {
        guestSpeakerSelect.disabled = disabled;
      }
      if (participantStatus) {
        participantStatus.textContent = nextStatus;
      }
    }

    async function setWorkspacePath(path) {
      const response = await fetch('/api/workspace', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ path }),
      });
      if (!response.ok) {
        const detail = await response.text();
        throw new Error(detail || response.statusText);
      }
      return response.json();
    }

    function workspaceUrl(name) {
      if (!name) return null;
      return "/workspace/" + name.split("/").map(encodeURIComponent).join("/");
    }

    function triggerDownload(url, filename) {
      if (!url) return;
      const anchor = document.createElement('a');
      anchor.href = url;
      if (filename) {
        anchor.download = filename;
      }
      document.body.appendChild(anchor);
      anchor.click();
      document.body.removeChild(anchor);
    }

    function humanFileSize(bytes) {
      if (bytes === null || bytes === undefined) return '‚Äî';
      if (bytes === 0) return '0 B';
      const units = ['B', 'KB', 'MB', 'GB', 'TB'];
      let value = bytes;
      let unitIndex = 0;
      while (value >= 1024 && unitIndex < units.length - 1) {
        value /= 1024;
        unitIndex += 1;
      }
      const decimals = unitIndex === 0 || value >= 10 ? 0 : 1;
      return `${value.toFixed(decimals)} ${units[unitIndex]}`;
    }

    function formatModified(timestamp) {
      if (!timestamp) return '‚Äî';
      try {
        return new Date(timestamp * 1000).toLocaleString();
      } catch (error) {
        return '‚Äî';
      }
    }

    function updateDownloadAllState() {
      if (!fileDownloadAllBtn) return;
      fileDownloadAllBtn.disabled = !workspaceProjectName;
    }

    function resetFileManagerSelection() {
      fileManagerState.selected.clear();
      if (fileManagerRows) {
        fileManagerRows.querySelectorAll('.file-row').forEach((row) => row.classList.remove('selected'));
        fileManagerRows.querySelectorAll('input[type="checkbox"]').forEach((checkbox) => {
          checkbox.checked = false;
        });
      }
      updateFileManagerActions();
    }

    function updateFileManagerActions() {
      if (!fileSelectionCount) return;
      const count = fileManagerState.selected.size;
      fileSelectionCount.textContent = count
        ? `${count} item${count === 1 ? '' : 's'} selected`
        : 'Select files to enable actions.';
      if (fileDownloadSelectedBtn) {
        fileDownloadSelectedBtn.disabled = count === 0;
      }
      if (fileDeleteSelectedBtn) {
        fileDeleteSelectedBtn.disabled = count === 0;
      }
      updateDownloadAllState();
    }

    function updateFileManagerBreadcrumbs() {
      if (!fileBreadcrumbs) return;
      fileBreadcrumbs.textContent = '';
      const crumbs = (fileManagerState.breadcrumbs && fileManagerState.breadcrumbs.length)
        ? fileManagerState.breadcrumbs
        : [{ label: 'Workspace', path: '.' }];
      crumbs.forEach((crumb, index) => {
        if (index > 0) {
          const divider = document.createElement('span');
          divider.textContent = '/';
          divider.style.opacity = 0.6;
          fileBreadcrumbs.appendChild(divider);
        }
        const button = document.createElement('button');
        button.type = 'button';
        button.textContent = crumb.label || crumb.path || '.';
        button.addEventListener('click', () => {
          refreshFileManager(crumb.path || '.');
        });
        fileBreadcrumbs.appendChild(button);
      });
    }

    function updateFileManagerPathLabel() {
      if (!fileManagerPath) return;
      const dir = fileManagerState.currentDir;
      const suffix = dir === '.' ? 'Workspace' : `Workspace/${dir}`;
      fileManagerPath.textContent = suffix;
    }

    function handleRowSelection(path, checked, rowElement) {
      if (!path) return;
      if (checked) {
        fileManagerState.selected.add(path);
        if (rowElement) rowElement.classList.add('selected');
      } else {
        fileManagerState.selected.delete(path);
        if (rowElement) rowElement.classList.remove('selected');
      }
      updateFileManagerActions();
    }

    function buildFileRow(entry) {
      const row = document.createElement('div');
      row.className = 'file-row';
      row.dataset.path = entry.path;
      if (entry.is_dir) {
        row.classList.add('directory');
      }

      const checkboxWrapper = document.createElement('div');
      const checkbox = document.createElement('input');
      checkbox.type = 'checkbox';
      checkbox.addEventListener('change', (event) => {
        handleRowSelection(entry.path, event.target.checked, row);
      });
      checkboxWrapper.appendChild(checkbox);
      row.appendChild(checkboxWrapper);

      const nameButton = document.createElement('button');
      nameButton.type = 'button';
      nameButton.className = 'file-name';
      const iconSvg = entry.is_dir
        ? '<svg viewBox="0 0 24 24"><path d="M4 6a2 2 0 0 1 2-2h4.172a2 2 0 0 1 1.414.586L12.828 6H18a2 2 0 0 1 2 2v8a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2Z"/></svg>'
        : '<svg viewBox="0 0 24 24"><path d="M6 2a2 2 0 0 0-2 2v16l6-3 6 3V4a2 2 0 0 0-2-2H6z"/></svg>';
      nameButton.innerHTML = `${iconSvg}<span>${entry.name}</span>`;
      if (entry.is_dir) {
        nameButton.addEventListener('click', () => {
          refreshFileManager(entry.path);
        });
      } else {
        nameButton.addEventListener('click', () => {
          const url = workspaceUrl(entry.path);
          const mediaInfo = isMediaFile(entry.name);
          if (mediaInfo.isMedia) {
            openMediaPreview(entry.name, url);
          } else {
            triggerDownload(url, entry.name);
          }
        });
      }
      row.appendChild(nameButton);

      const sizeSpan = document.createElement('span');
      sizeSpan.textContent = entry.is_dir ? '‚Äî' : humanFileSize(entry.size);
      row.appendChild(sizeSpan);

      const modifiedSpan = document.createElement('span');
      modifiedSpan.textContent = formatModified(entry.modified);
      row.appendChild(modifiedSpan);

      const actions = document.createElement('div');
      actions.className = 'file-actions';
      const downloadBtn = document.createElement('button');
      downloadBtn.type = 'button';
      downloadBtn.textContent = 'Download';
      downloadBtn.addEventListener('click', () => {
        downloadSelected([entry.path]);
      });
      const deleteBtn = document.createElement('button');
      deleteBtn.type = 'button';
      deleteBtn.textContent = 'Delete';
      deleteBtn.addEventListener('click', () => {
        deleteFiles([entry.path]);
      });
      actions.appendChild(downloadBtn);
      actions.appendChild(deleteBtn);
      row.appendChild(actions);

      return row;
    }

    function updateFileManagerRows() {
      if (!fileManagerRows) return;
      fileManagerRows.textContent = '';
      if (!fileManagerState.entries.length) {
        const empty = document.createElement('div');
        empty.className = 'file-empty-message';
        empty.textContent = 'No files in this directory yet.';
        fileManagerRows.appendChild(empty);
        return;
      }
      fileManagerState.entries.forEach((entry) => {
        const row = buildFileRow(entry);
        fileManagerRows.appendChild(row);
      });
    }

    function renderFileManager(data) {
      fileManagerState.currentDir = data.directory || '.';
      fileManagerState.entries = data.entries || [];
      fileManagerState.breadcrumbs = data.breadcrumbs || [];
      fileManagerState.selected.clear();
      updateFileManagerBreadcrumbs();
      updateFileManagerPathLabel();
      updateFileManagerRows();
      updateFileManagerActions();
      if (fileManagerStatus) {
        fileManagerStatus.textContent = '';
      }
      if (typeof data.project_name === 'string') {
        workspaceProjectName = data.project_name;
        updateDownloadAllState();
      }
    }

    async function refreshFileManager(dir = fileManagerState.currentDir) {
      if (!fileManagerModal || fileManagerModal.classList.contains('hidden')) return;
      try {
        if (fileManagerStatus) {
          fileManagerStatus.textContent = 'Loading‚Ä¶';
        }
        const params = new URLSearchParams();
        if (dir && dir !== '.') {
          params.set('dir', dir);
        }
        const response = await fetch(`/api/workspace/files?${params.toString()}`);
        const data = await response.json();
        if (!response.ok) {
          throw new Error(data.error || response.statusText);
        }
        renderFileManager(data);
      } catch (error) {
        console.error(error);
        if (fileManagerStatus) {
          fileManagerStatus.textContent = `Unable to list files: ${error.message}`;
        }
      }
    }

    function openFileManager(dir = '.') {
      if (!fileManagerModal) return;
      if (!workspaceInfo || !workspaceInfo.path) {
        alert('Select a project before managing files.');
        return;
      }
      fileManagerModal.classList.remove('hidden');
      fileManagerStatus.textContent = '';
      updateDownloadAllState();
      updateBodyModalState();
      refreshFileManager(dir);
    }

    function closeFileManager() {
      if (!fileManagerModal) return;
      fileManagerModal.classList.add('hidden');
      resetFileManagerSelection();
      if (fileManagerStatus) {
        fileManagerStatus.textContent = '';
      }
      updateBodyModalState();
    }

    async function deleteFiles(paths) {
      if (!paths || !paths.length) return;
      const confirmDelete = window.confirm(
        paths.length === 1
          ? `Delete ‚Äú${paths[0]}‚Äù? This action cannot be undone.`
          : `Delete ${paths.length} items? This action cannot be undone.`
      );
      if (!confirmDelete) return;

      try {
        const response = await fetch('/api/workspace/delete-files', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ paths }),
        });
        const data = await response.json();
        if (!response.ok) {
          throw new Error(data.error || response.statusText);
        }
        if (fileManagerStatus) {
          fileManagerStatus.textContent = `Deleted ${data.paths.length} item${data.paths.length === 1 ? '' : 's'}.`;
        }
        resetFileManagerSelection();
        await loadWorkspace({ refresh: true });
        await refreshFileManager(fileManagerState.currentDir);
      } catch (error) {
        console.error(error);
        if (fileManagerStatus) {
          fileManagerStatus.textContent = `Delete failed: ${error.message}`;
        }
      }
    }

    async function downloadSelected(paths) {
      if (!paths || !paths.length) return;
      if (paths.length === 1) {
        const relative = paths[0];
        const selectedEntry = fileManagerState.entries.find((entry) => entry.path === relative);
        const url = workspaceUrl(relative);
        if (selectedEntry && selectedEntry.is_dir) {
          const ok = await downloadZip(paths);
          if (ok) {
            resetFileManagerSelection();
          }
          return;
        } else {
          triggerDownload(url, selectedEntry ? selectedEntry.name : undefined);
          resetFileManagerSelection();
          return;
        }
      }
      const ok = await downloadZip(paths);
      if (ok) {
        resetFileManagerSelection();
      }
    }

    async function downloadZip(paths) {
      try {
        if (fileManagerStatus) {
          fileManagerStatus.textContent = 'Preparing download‚Ä¶';
        }
        const response = await fetch('/api/workspace/download-zip', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ paths }),
        });
        if (!response.ok) {
          const errorPayload = await response.json().catch(() => ({}));
          throw new Error(errorPayload.error || response.statusText);
        }
        const blob = await response.blob();
        const url = URL.createObjectURL(blob);
        triggerDownload(url, 'workspace-files.zip');
        setTimeout(() => URL.revokeObjectURL(url), 1500);
        if (fileManagerStatus) {
          fileManagerStatus.textContent = '';
        }
        return true;
      } catch (error) {
        console.error(error);
        if (fileManagerStatus) {
          fileManagerStatus.textContent = `Download failed: ${error.message}`;
        }
        return false;
      }
    }

    function downloadProjectArchive() {
      if (!workspaceProjectName) {
        if (fileManagerStatus) {
          fileManagerStatus.textContent = 'Project zip is only available for workspaces inside the Projects folder.';
        }
        return;
      }
      if (fileManagerStatus) {
        fileManagerStatus.textContent = 'Preparing project archive‚Ä¶';
      }
      const url = `/api/projects/download?project=${encodeURIComponent(workspaceProjectName)}`;
      triggerDownload(url, `${workspaceProjectName}.zip`);
      setTimeout(() => {
        if (fileManagerStatus && fileManagerModal && !fileManagerModal.classList.contains('hidden')) {
          fileManagerStatus.textContent = '';
        }
      }, 1200);
    }

    async function applyWorkspaceFromQuery() {
      const params = new URLSearchParams(window.location.search);
      const workspace = params.get('workspace');
      if (!workspace) return;
      try {
        await setWorkspacePath(workspace);
        try {
          window.localStorage.setItem('podfreeWorkspacePath', workspace);
        } catch (error) {
          console.warn('Unable to persist workspace path from query:', error);
        }
      } catch (error) {
        console.error('Failed to set workspace from URL parameter:', error);
        statusLine.textContent = `Workspace unavailable: ${error.message}`;
      } finally {
        params.delete('workspace');
        const nextSearch = params.toString();
        const nextUrl = `${window.location.pathname}${nextSearch ? `?${nextSearch}` : ''}${window.location.hash || ''}`;
        window.history.replaceState({}, '', nextUrl);
      }
    }

    async function applyPendingWorkspace() {
      let pendingPath = null;
      try {
        pendingPath = window.localStorage.getItem('podfreeWorkspacePath');
      } catch (error) {
        console.warn('Unable to read stored workspace path:', error);
      }
      if (!pendingPath) return;
      try {
        await setWorkspacePath(pendingPath);
      } catch (error) {
        console.error('Failed to restore workspace from storage:', error);
        statusLine.textContent = `Workspace unavailable: ${error.message}`;
      }
      try {
        window.localStorage.removeItem('podfreeWorkspacePath');
      } catch (error) {
        console.warn('Unable to clear stored workspace path:', error);
      }
    }

    function updateLinks(path) {
      const params = new URLSearchParams();
      if (path) params.set('workspace', path);
      // No auxiliary links in Editor header, but keep placeholder for future use
      const _suffix = params.toString() ? `?${params.toString()}` : '';

      // Show/hide workspace-required navigation links
      const workspaceLinks = document.querySelectorAll('.nav-link.workspace-required');
      if (path) {
        workspaceLinks.forEach(link => link.classList.add('visible'));
      } else {
        workspaceLinks.forEach(link => link.classList.remove('visible'));
      }
    }

    function workspaceLabel(summary) {
      if (!summary || !summary.path) return null;
      const parts = summary.path.split(/[/\\]+/).filter(Boolean);
      return parts.length ? parts[parts.length - 1] : null;
    }

    function updatePageHeader(summary) {
      const label = workspaceLabel(summary);
      if (pageTitle) {
        pageTitle.textContent = label ? `Edit ${label}` : 'Edit Project';
      }
      if (!label) {
        setTitleFormState({ disabled: true, value: '', status: 'Open a project from Projects ‚Üí' });
      }
    }

    function setTitleFormState({ disabled = false, value = '', status = 'Idle' } = {}) {
      if (titleInput) {
        titleInput.disabled = disabled;
        if (typeof value === 'string') {
          titleInput.value = value;
        }
      }
      if (titleSave) {
        titleSave.disabled = disabled;
      }
      if (titleStatus) {
        titleStatus.textContent = status;
      }
    }

    function extractTitleSection(content) {
      if (typeof content !== 'string') return '';
      const lines = content.split(/\r?\n/);
      let idx = lines.findIndex((line) => line.trim().toLowerCase() === '## title');
      if (idx === -1) return '';
      idx += 1;
      while (idx < lines.length && !lines[idx].trim()) idx += 1;
      return idx < lines.length ? lines[idx].trim() : '';
    }

    function replaceTitleSection(content, newTitle) {
      const lines = content.split(/\r?\n/);
      let idx = lines.findIndex((line) => line.trim().toLowerCase() === '## title');
      if (idx === -1) {
        lines.push('', '## Title', newTitle, '');
        return lines.join('\n');
      }
      idx += 1;
      while (idx < lines.length && !lines[idx].trim()) {
        idx += 1;
      }
      if (idx >= lines.length) {
        lines.push(newTitle, '');
      } else {
        lines[idx] = newTitle;
      }
      return lines.join('\n');
    }

    function replaceSectionFirstLine(content, heading, newLine) {
      const lines = content.split(/\r?\n/);
      const target = String(heading || '').trim().toLowerCase();
      let idx = lines.findIndex((line) => line.trim().toLowerCase() === target);
      if (idx === -1) {
        lines.push('', heading, newLine, '');
        return lines.join('\n');
      }
      idx += 1;
      while (idx < lines.length && !lines[idx].trim()) {
        idx += 1;
      }
      if (idx >= lines.length || lines[idx].startsWith('## ')) {
        lines.splice(idx, 0, newLine, '');
      } else {
        lines[idx] = newLine;
      }
      return lines.join('\n');
    }

    function extractSectionFirstLine(content, headings) {
      if (!content) return '';
      const lines = content.split(/\r?\n/);
      const normalized = lines.map((line) => line.trim().toLowerCase());
      let idx = -1;
      for (const heading of headings) {
        const target = `## ${heading}`.toLowerCase();
        idx = normalized.indexOf(target);
        if (idx !== -1) break;
      }
      if (idx === -1) return '';
      idx += 1;
      while (idx < lines.length && !lines[idx].trim()) idx += 1;
      return idx < lines.length ? lines[idx].trim() : '';
    }

    function normalizeSpeakerId(raw) {
      if (raw === undefined || raw === null) return { raw: null, numeric: null };
      if (typeof raw === 'number' && Number.isFinite(raw)) {
        return { raw, numeric: raw };
      }
      const str = String(raw);
      const match = str.match(/(-?\d+(?:\.\d+)?)/);
      const numeric = match ? Number(match[1]) : null;
      return { raw, numeric: Number.isFinite(numeric) ? numeric : null };
    }

    function buildSpeakerMapping(segments) {
      const encountered = [];
      segments.forEach((seg) => {
        const id = seg.speaker;
        if (id === undefined || id === null) return;
        if (!encountered.some((entry) => entry.raw === id)) {
          encountered.push({ raw: id, ...normalizeSpeakerId(id), order: encountered.length });
        }
      });
      const map = new Map();
      const assigned = new Set();
      const assign = (entry, role, label) => {
        const payload = { role, label };
        const { raw, numeric } = entry;
        map.set(raw, payload);
        const rawStr = typeof raw === 'string' ? raw : null;
        if (rawStr) {
          map.set(rawStr, payload);
        }
        if (Number.isFinite(numeric)) {
          map.set(numeric, payload);
          map.set(String(numeric), payload);
        }
        if (role) assigned.add(role);
      };
      const interviewerLabel = interviewerName || 'Interviewer';
      const guestLabel = guestName || 'Guest';

      // Use manual speaker ID assignments
      encountered.forEach((entry, index) => {
        const numeric = Number.isFinite(entry.numeric) ? entry.numeric : null;

        // Check if this entry matches the manually assigned interviewer speaker ID
        if (numeric === interviewerSpeakerId || entry.raw === interviewerSpeakerId || entry.raw === String(interviewerSpeakerId)) {
          assign(entry, 'interviewer', interviewerLabel);
          return;
        }

        // Check if this entry matches the manually assigned guest speaker ID
        if (numeric === guestSpeakerId || entry.raw === guestSpeakerId || entry.raw === String(guestSpeakerId)) {
          assign(entry, 'guest', guestLabel);
          return;
        }

        // Otherwise assign as other
        const rawLabel = typeof entry.raw === 'string' ? entry.raw.trim() : '';
        const label = rawLabel || `Speaker ${Number.isFinite(numeric) ? numeric : index + 1}`;
        assign(entry, 'other', label);
      });

      // Handle null/undefined speakers if they're assigned to interviewer or guest
      if (interviewerSpeakerId === null) {
        speakerMap.set(null, { role: 'interviewer', label: interviewerLabel });
        speakerMap.set(undefined, { role: 'interviewer', label: interviewerLabel });
      }
      if (guestSpeakerId === null) {
        speakerMap.set(null, { role: 'guest', label: guestLabel });
        speakerMap.set(undefined, { role: 'guest', label: guestLabel });
      }

      speakerMap = map;
    }

    function resolveSpeakerInfo(speaker) {
      if (speaker === undefined || speaker === null) {
        return { role: 'narration', label: 'Narration' };
      }
      if (speakerMap.has(speaker)) {
        return speakerMap.get(speaker);
      }
      return { role: 'other', label: `Speaker ${speaker}` };
    }

    function speakerClassForRole(role) {
      switch (role) {
        case 'interviewer':
          return 'speaker-interviewer';
        case 'guest':
          return 'speaker-guest';
        case 'narration':
          return 'speaker-narration';
        default:
          return 'speaker-other';
      }
    }

    function resetTranscript(message, status = 'Idle') {
      transcriptSource = { kind: null, name: null, url: null };
      wordSpans = [];
      activeWordIndex = -1;
      speakerMap = new Map();
      if (transcriptStatus) {
        transcriptStatus.textContent = status;
      }
      if (transcriptEl) {
        transcriptEl.textContent = '';
        const paragraph = document.createElement('p');
        paragraph.textContent = message;
        transcriptEl.appendChild(paragraph);
      }
    }

    function parseSRT(data) {
      const entries = [];
      const blocks = data.split(/\r?\n\r?\n+/);
      for (const block of blocks) {
        const lines = block.trim().split(/\r?\n/).filter(Boolean);
        if (lines.length < 2) continue;
        let idx = 0;
        if (/^\d+$/.test(lines[0].trim())) {
          idx = 1;
        }
        const times = lines[idx];
        const match = times.match(/(.+?)\s+-->\s+(.+?)/);
        if (!match) continue;
        const text = lines.slice(idx + 1).join(' ').replace(/\s+/g, ' ').trim();
        if (!text) continue;
        const label = match[1].split(',')[0];
        const startSeconds = timecodeToSeconds(label);
        const endSeconds = parseTimecode(match[2]);
        entries.push({ time: label, seconds: startSeconds, endSeconds, text, speaker: null });
      }
      return entries;
    }

    function renderTranscript(segments) {
      if (!transcriptEl || !transcriptStatus) return;
      if (!segments.length) {
        transcriptStatus.textContent = 'Empty';
        transcriptEl.innerHTML = '<p>Transcript file loaded but no caption entries were detected.</p>';
        return;
      }
      transcriptStatus.textContent = 'Ready';

      // Store segments globally for re-rendering when speaker mapping changes
      currentTranscriptSegments = segments;

      // Clean up state
      wordSpans = [];
      activeWordIndex = -1;
      selectedWords.clear();
      deletedWords.clear();
      stopPlaybackTracking();
      userIsScrolling = false;
      if (scrollTimeout) {
        clearTimeout(scrollTimeout);
        scrollTimeout = null;
      }
      if (selectionMode) {
        selectionMode = false;
        if (selectionModeBtn) selectionModeBtn.classList.remove('active');
      }
      updateWordStats();
      const sorted = [...segments].sort((a, b) => {
        const aSec = Number(a.seconds ?? Number.MAX_VALUE);
        const bSec = Number(b.seconds ?? Number.MAX_VALUE);
        return aSec - bSec;
      });
      buildSpeakerMapping(sorted);
      const described = sorted.map((segment) => ({
        ...segment,
        info: resolveSpeakerInfo(segment.speaker),
      }));
      const mergedSegments = mergeSegmentsBySpeaker(described);
      const fragment = document.createDocumentFragment();
      mergedSegments.forEach((segment) => {
        const info = segment.info || resolveSpeakerInfo(segment.speaker);
        const entry = document.createElement('div');
        entry.className = `transcript-entry ${speakerClassForRole(info?.role)}`;

        const meta = document.createElement('div');
        meta.className = 'transcript-meta';
        const labelParts = [];
        if (info && info.label) labelParts.push(info.label);
        if (Number.isFinite(segment.seconds)) {
          labelParts.push(formatTime(Number(segment.seconds)));
        } else if (segment.time) {
          labelParts.push(segment.time);
        }
        if (!labelParts.length) {
          labelParts.push('Speaker');
        }
        meta.textContent = labelParts.join(' ¬∑ ');
        entry.appendChild(meta);

        const paragraph = document.createElement('p');

        const tokens = segmentText(segment.text || '');
        let words = tokens.filter((token) => token.isWord);
        const startSeconds = Number(segment.seconds) || 0;
        let endSeconds = Number(segment.endSeconds);
        if (!Number.isFinite(endSeconds) || endSeconds <= startSeconds) {
          const approx = Math.max(words.length * 0.32, 0.6);
          endSeconds = startSeconds + approx;
        }
        if (!words.length && segment.text && segment.text.trim()) {
          tokens.length = 0;
          tokens.push({ value: segment.text.trim(), isWord: true });
          words = tokens;
        }

        const totalWords = Math.max(words.length, 1);
        const step = Math.max((endSeconds - startSeconds) / totalWords, 0.12);
        let wordIndex = 0;

        tokens.forEach((token) => {
          if (!token.isWord) {
            paragraph.append(token.value);
            return;
          }
          const span = document.createElement('span');
          span.className = 'word';
          span.textContent = token.value;
          const wordStart = startSeconds + step * wordIndex;
          const isLastWord = wordIndex === totalWords - 1;
          let wordEnd = isLastWord ? endSeconds : Math.min(startSeconds + step * (wordIndex + 1), endSeconds);
          if (!Number.isFinite(wordEnd) || wordEnd <= wordStart) {
            wordEnd = wordStart + 0.12;
          }
          const wordEntry = { element: span, start: wordStart, end: wordEnd, segment: entry };
          const index = wordSpans.push(wordEntry) - 1;
          span.dataset.start = String(wordStart);
          span.dataset.index = String(index);
          span.title = `Seek to ${formatTime(wordStart)}`;

          span.addEventListener('mousedown', (e) => {
            if (selectionMode) {
              e.preventDefault();
              isDragging = true;
              dragStartIndex = index;
              dragCurrentIndex = index;
              dragStartSegment = entry;
            }
          });

          span.addEventListener('mouseenter', () => {
            if (selectionMode && isDragging && dragStartSegment === entry) {
              dragCurrentIndex = index;
              updateDragSelection();
            }
          });

          span.addEventListener('click', (e) => {
            if (selectionMode) {
              // Click is a single word toggle (handled in mouseup if no drag)
              e.preventDefault();
            } else {
              // Re-enable auto-scroll when user clicks a word to seek
              userIsScrolling = false;
              if (scrollTimeout) {
                clearTimeout(scrollTimeout);
                scrollTimeout = null;
              }
              media.currentTime = Math.max(0, wordStart - SEEK_EPSILON);
              highlightWordByIndex(index);
              media.play().catch(() => {});
            }
          });
          paragraph.appendChild(span);
          wordIndex += 1;
        });

        entry.appendChild(paragraph);
        fragment.appendChild(entry);
      });
      transcriptEl.textContent = '';
      transcriptEl.appendChild(fragment);
      updateStatusLine();
      updateExportButtonStyles();
    }

    function highlightWordByIndex(index) {
      if (index === activeWordIndex || index < 0 || index >= wordSpans.length) {
        return;
      }
      if (activeWordIndex >= 0) {
        wordSpans[activeWordIndex].element.classList.remove('active');
      }
      const entry = wordSpans[index];
      entry.element.classList.add('active');
      activeWordIndex = index;

      // Skip auto-scroll if user is manually scrolling
      if (!transcriptEl || userIsScrolling) return;

      const containerRect = transcriptEl.getBoundingClientRect();
      const spanRect = entry.element.getBoundingClientRect();
      const offset = 48;
      if (spanRect.top < containerRect.top + offset || spanRect.bottom > containerRect.bottom - offset) {
        entry.element.scrollIntoView({ behavior: 'smooth', block: 'center' });
      }
    }

    function updateActiveWord(time) {
      if (!wordSpans.length) return;
      let index = activeWordIndex;
      if (index >= 0) {
        const current = wordSpans[index];
        if (time >= current.start && time < current.end) {
          return;
        }
        if (time >= current.end) {
          while (index + 1 < wordSpans.length && time >= wordSpans[index + 1].start) {
            index += 1;
            if (time < wordSpans[index].end) break;
          }
          if (time >= wordSpans[index].start && time < wordSpans[index].end) {
            highlightWordByIndex(index);
            return;
          }
        }
        if (time < current.start) {
          while (index > 0 && time < wordSpans[index].start) {
            index -= 1;
            if (time >= wordSpans[index].start) break;
          }
          if (time >= wordSpans[index].start && time < wordSpans[index].end) {
            highlightWordByIndex(index);
            return;
          }
        }
      }
      let low = 0;
      let high = wordSpans.length - 1;
      let found = -1;
      while (low <= high) {
        const mid = Math.floor((low + high) / 2);
        const entry = wordSpans[mid];
        if (time < entry.start) {
          high = mid - 1;
        } else if (time >= entry.end) {
          low = mid + 1;
        } else {
          found = mid;
          break;
        }
      }
      if (found !== -1) {
        highlightWordByIndex(found);
      }
    }

    // Word editing functions
    function updateWordStats() {
      if (!wordStatsEl) return;
      const total = wordSpans.length;
      const deleted = deletedWords.size;
      const selected = selectedWords.size;

      // Calculate estimated time based on edits
      let totalDuration = 0;
      let deletedDuration = 0;

      wordSpans.forEach((word, index) => {
        const duration = word.end - word.start;
        totalDuration += duration;
        if (deletedWords.has(index)) {
          deletedDuration += duration;
        }
      });

      const editedDuration = totalDuration - deletedDuration;

      const formatDuration = (seconds) => {
        const hrs = Math.floor(seconds / 3600);
        const mins = Math.floor((seconds % 3600) / 60);
        const secs = Math.floor(seconds % 60);
        if (hrs > 0) {
          return `${hrs}h ${mins}m ${secs}s`;
        } else if (mins > 0) {
          return `${mins}m ${secs}s`;
        } else {
          return `${secs}s`;
        }
      };

      const originalTime = formatDuration(totalDuration);
      const editedTime = formatDuration(editedDuration);
      const savedTime = formatDuration(deletedDuration);

      if (deletedDuration > 0) {
        wordStatsEl.textContent = `Final: ${editedTime} ‚Ä¢ Saved: ${savedTime}`;
      } else {
        wordStatsEl.textContent = `Final: ${editedTime}`;
      }
    }

    function toggleSelectionMode() {
      selectionMode = !selectionMode;
      if (!selectionMode) {
        // Clear selections when exiting selection mode
        selectedWords.forEach(index => {
          if (wordSpans[index]) {
            wordSpans[index].element.classList.remove('selected');
          }
        });
        selectedWords.clear();
        if (deleteSelectedBtn) deleteSelectedBtn.disabled = true;
        if (restoreSelectedBtn) restoreSelectedBtn.disabled = true;
        if (transcriptEl) transcriptEl.classList.remove('selecting');
      } else {
        if (transcriptEl) transcriptEl.classList.add('selecting');
      }
      updateWordStats();
    }

    function toggleWordSelection(index) {
      if (!selectionMode) return;
      if (selectedWords.has(index)) {
        selectedWords.delete(index);
        wordSpans[index].element.classList.remove('selected');
      } else {
        selectedWords.add(index);
        wordSpans[index].element.classList.add('selected');
      }

      // Update button states
      if (deleteSelectedBtn) {
        deleteSelectedBtn.disabled = selectedWords.size === 0;
      }
      if (restoreSelectedBtn) {
        // Enable restore button only if there are selected words that are deleted
        const hasDeletedSelected = Array.from(selectedWords).some(idx => deletedWords.has(idx));
        restoreSelectedBtn.disabled = !hasDeletedSelected;
      }

      updateWordStats();
    }

    function updateDragSelection() {
      if (!selectionMode || !isDragging) return;

      const minIndex = Math.min(dragStartIndex, dragCurrentIndex);
      const maxIndex = Math.max(dragStartIndex, dragCurrentIndex);

      // Add all words in the current drag range
      for (let i = minIndex; i <= maxIndex; i++) {
        if (wordSpans[i] && wordSpans[i].segment === dragStartSegment) {
          if (!selectedWords.has(i)) {
            selectedWords.add(i);
            wordSpans[i].element.classList.add('selected');
          }
        }
      }

      // Update button states
      if (deleteSelectedBtn) {
        deleteSelectedBtn.disabled = selectedWords.size === 0;
      }
      if (restoreSelectedBtn) {
        const hasDeletedSelected = Array.from(selectedWords).some(idx => deletedWords.has(idx));
        restoreSelectedBtn.disabled = !hasDeletedSelected;
      }

      updateWordStats();
    }

    function checkForUnsavedChanges() {
      // Compare current deletedWords with savedDeletedWords
      if (deletedWords.size !== savedDeletedWords.size) {
        hasUnsavedChanges = true;
        // Reset export completion states when new edits are made
        videoExportCompleted = false;
        audioExportCompleted = false;
        updateExportButtonStyles();
        updateStatusLine();
        return;
      }
      for (const index of deletedWords) {
        if (!savedDeletedWords.has(index)) {
          hasUnsavedChanges = true;
          // Reset export completion states when new edits are made
          videoExportCompleted = false;
          audioExportCompleted = false;
          updateExportButtonStyles();
          updateStatusLine();
          return;
        }
      }
      hasUnsavedChanges = false;
      updateExportButtonStyles();
    }

    function updateExportButtonStyles() {
      if (exportVideoBtn) {
        const isVideoUpToDate = videoExportCompleted || checkRenderUpToDate('video');
        if (isVideoUpToDate) {
          exportVideoBtn.style.background = 'rgba(74, 222, 128, 0.16)';
          exportVideoBtn.style.borderColor = 'rgba(74, 222, 128, 0.45)';
          exportVideoBtn.style.color = '';
        } else {
          exportVideoBtn.style.background = '';
          exportVideoBtn.style.borderColor = '';
          exportVideoBtn.style.color = '';
        }
      }
      if (exportAudioBtn) {
        const isAudioUpToDate = audioExportCompleted || checkRenderUpToDate('audio');
        if (isAudioUpToDate) {
          exportAudioBtn.style.background = 'rgba(74, 222, 128, 0.16)';
          exportAudioBtn.style.borderColor = 'rgba(74, 222, 128, 0.45)';
          exportAudioBtn.style.color = '';
        } else {
          exportAudioBtn.style.background = '';
          exportAudioBtn.style.borderColor = '';
          exportAudioBtn.style.color = '';
        }
      }
    }

    function toggleWordDeleted(index) {
      if (deletedWords.has(index)) {
        deletedWords.delete(index);
        wordSpans[index].element.classList.remove('deleted');
      } else {
        deletedWords.add(index);
        wordSpans[index].element.classList.add('deleted');
      }

      // Update restore button state if in selection mode
      if (selectionMode && restoreSelectedBtn) {
        const hasDeletedSelected = Array.from(selectedWords).some(idx => deletedWords.has(idx));
        restoreSelectedBtn.disabled = !hasDeletedSelected;
      }

      checkForUnsavedChanges();
      updateWordStats();
    }

    function deleteSelectedWords() {
      if (selectedWords.size === 0) return;
      selectedWords.forEach(index => {
        deletedWords.add(index);
        wordSpans[index].element.classList.remove('selected');
        wordSpans[index].element.classList.add('deleted');
      });
      selectedWords.clear();
      if (deleteSelectedBtn) deleteSelectedBtn.disabled = true;
      checkForUnsavedChanges();
      updateWordStats();
    }

    function restoreSelectedWords() {
      if (selectedWords.size === 0) return;
      selectedWords.forEach(index => {
        if (deletedWords.has(index)) {
          deletedWords.delete(index);
          wordSpans[index].element.classList.remove('deleted');
        }
        wordSpans[index].element.classList.remove('selected');
      });
      selectedWords.clear();
      if (restoreSelectedBtn) restoreSelectedBtn.disabled = true;
      checkForUnsavedChanges();
      updateWordStats();
    }

    function getEditedWords() {
      return wordSpans.map((entry, index) => ({
        word: entry.element.textContent,
        start: entry.start,
        end: entry.end,
        deleted: deletedWords.has(index)
      }));
    }

    async function exportEditedVideo() {
      if (!workspaceFiles.video) {
        alert('No video file available for export');
        return;
      }

      const editedWords = getEditedWords();
      const deletedCount = deletedWords.size;

      if (deletedCount === 0) {
        if (!confirm('No words have been deleted. Export original video anyway?')) {
          return;
        }
      }

      try {
        exportVideoBtn.disabled = true;

        const response = await fetch('/api/export-video', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            videoFile: workspaceFiles.video,
            editedWords: editedWords
          })
        });

        const data = await response.json();
        if (!response.ok) {
          throw new Error(data.error || 'Render failed');
        }

        const card = addJobCard(data.job_id, `Render Video`);
        const job = await waitForJob(data.job_id, (update) => {
          card.status.textContent = `${update.status} ‚Äî ${update.message || ''}`;
          const progress = update.progress ?? (update.status === 'running' ? 50 : 0);
          card.progressFill.style.width = `${Math.min(progress, 100)}%`;

          // Display percentage and estimated time
          let progressText = `${Math.round(progress)}%`;
          if (update.eta) {
            progressText += ` ‚Ä¢ ETA: ${update.eta}`;
          }
          card.progressInfo.textContent = progressText;
        });

        if (job.status === 'completed') {
          videoExportCompleted = true;
          saveRenderState('video');
          updateExportButtonStyles();
          addLogMessage(`Video render completed! Output: ${data.output_file}`, 'success');
        } else {
          addLogMessage(`Video render failed: ${job.message || 'Unknown error'}`, 'error');
        }

        await loadWorkspace();
      } catch (error) {
        console.error('Render error:', error);
        addLogMessage(`Render failed: ${error.message}`, 'error');
      } finally {
        exportVideoBtn.disabled = false;
      }
    }

    async function exportEditedAudio() {
      const sourceFile = workspaceFiles.audio || workspaceFiles.video;
      if (!sourceFile) {
        alert('No audio or video file available for render');
        return;
      }

      const editedWords = getEditedWords();
      const deletedCount = deletedWords.size;

      if (deletedCount === 0) {
        if (!confirm('No words have been deleted. Render original audio anyway?')) {
          return;
        }
      }

      try {
        exportAudioBtn.disabled = true;

        const response = await fetch('/api/export-audio', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            sourceFile: sourceFile,
            editedWords: editedWords
          })
        });

        const data = await response.json();
        if (!response.ok) {
          throw new Error(data.error || 'Render failed');
        }

        const card = addJobCard(data.job_id, `Render Audio`);
        const job = await waitForJob(data.job_id, (update) => {
          card.status.textContent = `${update.status} ‚Äî ${update.message || ''}`;
          const progress = update.progress ?? (update.status === 'running' ? 50 : 0);
          card.progressFill.style.width = `${Math.min(progress, 100)}%`;

          // Display percentage and estimated time
          let progressText = `${Math.round(progress)}%`;
          if (update.eta) {
            progressText += ` ‚Ä¢ ETA: ${update.eta}`;
          }
          card.progressInfo.textContent = progressText;
        });

        if (job.status === 'completed') {
          audioExportCompleted = true;
          saveRenderState('audio');
          updateExportButtonStyles();
          addLogMessage(`Audio render completed! Output: ${data.output_file}`, 'success');
        } else {
          addLogMessage(`Audio render failed: ${job.message || 'Unknown error'}`, 'error');
        }

        await loadWorkspace();
      } catch (error) {
        console.error('Render error:', error);
        addLogMessage(`Audio render failed: ${error.message}`, 'error');
      } finally {
        exportAudioBtn.disabled = false;
      }
    }

    async function saveTranscriptEdits() {
      if (!workspaceProjectName || !transcriptSource || !transcriptSource.name) {
        addLogMessage('Cannot save: No project or transcript loaded', 'error');
        return;
      }

      const deletedIndices = Array.from(deletedWords);
      const projectName = workspaceProjectName;
      const transcriptFile = transcriptSource.name;

      try {
        saveEditsBtn.disabled = true;

        const response = await fetch('/api/save-transcript-edits', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            projectName: projectName,
            transcriptFile: transcriptFile,
            deletedIndices: deletedIndices
          })
        });

        const data = await response.json();
        if (!response.ok) {
          throw new Error(data.error || 'Save failed');
        }

        // Update saved state
        savedDeletedWords = new Set(deletedWords);
        hasUnsavedChanges = false;

        addLogMessage(`Saved ${data.deletedCount} deleted word edits`, 'success');
        console.log(`Saved ${data.deletedCount} deleted word indices`);
      } catch (error) {
        console.error('Save error:', error);
        addLogMessage(`Failed to save edits: ${error.message}`, 'error');
      } finally {
        saveEditsBtn.disabled = false;
      }
    }

    async function loadSavedEdits() {
      if (!workspaceProjectName || !transcriptSource || !transcriptSource.name) {
        console.log('Cannot load saved edits: No project or transcript loaded');
        return;
      }

      const projectName = workspaceProjectName;
      const transcriptFile = transcriptSource.name;

      try {
        const response = await fetch(
          `/api/load-transcript-edits?projectName=${encodeURIComponent(projectName)}&transcriptFile=${encodeURIComponent(transcriptFile)}`
        );

        const data = await response.json();

        if (data.deletedIndices && Array.isArray(data.deletedIndices) && data.deletedIndices.length > 0) {
          console.log(`Loading ${data.deletedIndices.length} saved edits`);

          // Clear existing edits and apply saved ones
          deletedWords.clear();
          for (const index of data.deletedIndices) {
            deletedWords.add(index);
          }

          // Update saved state
          savedDeletedWords = new Set(deletedWords);
          hasUnsavedChanges = false;

          // Update UI to reflect loaded edits
          updateDeletedWordsUI();
          updateWordStats();
          updateStatusLine();
          updateEditedDuration();
          updateExportButtonStyles();

          console.log(`Loaded ${data.deletedIndices.length} deleted word indices`);
        } else {
          console.log('No saved edits found for this transcript');
          savedDeletedWords = new Set();
          hasUnsavedChanges = false;
          updateStatusLine();
          updateExportButtonStyles();
        }
      } catch (error) {
        console.error('Load edits error:', error);
        // Don't alert on load error - just log it
      }
    }

    function updateDeletedWordsUI() {
      // Update visual state of all words based on deletedWords Set
      wordSpans.forEach((entry, index) => {
        if (deletedWords.has(index)) {
          entry.element.classList.add('deleted');
        } else {
          entry.element.classList.remove('deleted');
        }
      });
    }

    // Real-time preview: skip deleted words during playback
    function startPlaybackTracking() {
      if (playbackTrackingInterval) return; // Already tracking

      playbackTrackingInterval = setInterval(() => {
        if (media.paused || isCurrentlySeeking) return;

        const currentTime = media.currentTime;

        // Find the current word (if any)
        const currentWordIndex = wordSpans.findIndex(w =>
          currentTime >= w.start && currentTime < w.end
        );

        // Check if we're on a deleted word
        if (currentWordIndex >= 0 && deletedWords.has(currentWordIndex)) {
          skipToNextNonDeleted();
          return;
        }

        // Also check if we're approaching a deleted word
        // Find the next upcoming word
        const nextWordIndex = wordSpans.findIndex(w => w.start > currentTime);

        // If the next word is deleted and very close (within 0.1s), skip to next non-deleted
        if (nextWordIndex >= 0 && deletedWords.has(nextWordIndex)) {
          const nextWord = wordSpans[nextWordIndex];
          if ((nextWord.start - currentTime) < 0.1) {
            skipToNextNonDeleted();
            return;
          }
        }

        // Check if we've passed all kept words
        let lastKeptIndex = -1;
        for (let i = wordSpans.length - 1; i >= 0; i--) {
          if (!deletedWords.has(i)) {
            lastKeptIndex = i;
            break;
          }
        }

        if (lastKeptIndex >= 0 && currentTime > wordSpans[lastKeptIndex].end) {
          // We're past all kept content, pause the video
          media.pause();
        }
      }, 50); // Check every 50ms
    }

    function stopPlaybackTracking() {
      if (playbackTrackingInterval) {
        clearInterval(playbackTrackingInterval);
        playbackTrackingInterval = null;
      }
      isCurrentlySeeking = false; // Reset seeking flag when tracking stops
    }

    function skipToNextNonDeleted() {
      const currentTime = media.currentTime;

      // Find the next non-deleted word
      const nextWordIndex = wordSpans.findIndex((w, idx) =>
        w.start > currentTime && !deletedWords.has(idx)
      );

      if (nextWordIndex >= 0) {
        isCurrentlySeeking = true;
        media.currentTime = wordSpans[nextWordIndex].start;
      } else {
        // No more non-deleted words - pause at end of edited content
        media.pause();
      }
    }

    function extractSpeakerId(speakerValue) {
      // Handle null/undefined
      if (speakerValue === null || speakerValue === undefined) {
        return null;
      }
      // If it's already a number, return it
      if (typeof speakerValue === 'number') {
        return speakerValue;
      }
      // If it's a string like 'speaker_0', extract the number
      if (typeof speakerValue === 'string') {
        const match = speakerValue.match(/(\d+)/);
        if (match) {
          return parseInt(match[1], 10);
        }
      }
      return null;
    }

    function parseTranscriptJSON(data) {
      const entries = [];
      if (!data || typeof data !== 'object') {
        return entries;
      }
      const contributions = Array.isArray(data.contributions) ? data.contributions : [];
      if (contributions.length) {
        contributions.forEach((item) => {
          const seconds = item.start_time_seconds ?? item.start_time ?? 0;
          let endSeconds = item.end_time_seconds ?? item.end_time;
          const text = (item.text || '').trim();
          if (!text) return;
          if (!Number.isFinite(endSeconds) || Number(endSeconds) <= Number(seconds)) {
            const approx = Math.max(text.split(/\s+/).length * 0.32, 0.6);
            endSeconds = Number(seconds) + approx;
          }
          entries.push({
            time: formatSecondsLabel(seconds),
            seconds: Number(seconds) || 0,
            endSeconds: Number(endSeconds) || (Number(seconds) || 0),
            text,
            speaker: extractSpeakerId(item.speaker ?? item.speaker_id ?? item.madeBy ?? null),
          });
        });
        return entries;
      }

      const utterances = data?.results?.utterances;
      if (Array.isArray(utterances) && utterances.length) {
        utterances.forEach((utt) => {
          const text = (utt.transcript || utt.text || '').trim();
          if (!text) return;
          const start = Number(utt.start ?? utt.start_time ?? 0) || 0;
          let end = Number(utt.end ?? utt.end_time);
          if (!Number.isFinite(end) || end <= start) {
            const approx = Math.max(text.split(/\s+/).length * 0.32, 0.6);
            end = start + approx;
          }
          entries.push({
            time: formatSecondsLabel(start),
            seconds: start,
            endSeconds: end,
            text,
            speaker: extractSpeakerId(utt.speaker ?? utt.speaker_id ?? utt.madeBy ?? null),
          });
        });
        return entries;
      }

      const paragraphs = data?.results?.channels?.[0]?.alternatives?.[0]?.paragraphs?.paragraphs;
      if (Array.isArray(paragraphs) && paragraphs.length) {
        paragraphs.forEach((para) => {
          const start = para.start ?? 0;
          let end = para.end;
          const text = (para.text || '').trim();
          if (!text) return;
          if (!Number.isFinite(end) || Number(end) <= Number(start)) {
            const approx = Math.max(text.split(/\s+/).length * 0.32, 0.6);
            end = Number(start) + approx;
          }
          entries.push({
            time: formatSecondsLabel(start),
            seconds: Number(start) || 0,
            endSeconds: Number(end) || (Number(start) || 0),
            text,
            speaker: extractSpeakerId(para.speaker ?? para.speaker_id ?? para.madeBy ?? null),
          });
        });
        return entries;
      }

      const words = data?.results?.channels?.[0]?.alternatives?.[0]?.words;
      if (Array.isArray(words) && words.length) {
        const buffer = [];
        let currentStart = words[0]?.start ?? 0;
        let chunkSpeaker = extractSpeakerId(words[0]?.speaker ?? words[0]?.speaker_id ?? words[0]?.madeBy ?? null);
        words.forEach((word) => {
          if ((buffer.join(' ') + ' ' + (word.word || '')).length > 80) {
            const chunkEnd = word.start ?? word.end ?? (currentStart + Math.max(buffer.length * 0.32, 0.6));
            entries.push({
              time: formatSecondsLabel(currentStart),
              seconds: Number(currentStart) || 0,
              endSeconds: Number(chunkEnd) || Number(currentStart) || 0,
              text: buffer.join(' '),
              speaker: chunkSpeaker,
            });
            buffer.length = 0;
            currentStart = word.start ?? currentStart;
            chunkSpeaker = extractSpeakerId(word.speaker ?? word.speaker_id ?? word.madeBy ?? chunkSpeaker);
          }
          if (word.word) buffer.push(word.word);
        });
        if (buffer.length) {
          const approx = Math.max(buffer.length * 0.32, 0.6);
          entries.push({
            time: formatSecondsLabel(currentStart),
            seconds: Number(currentStart) || 0,
            endSeconds: Number(currentStart + approx) || 0,
            text: buffer.join(' '),
            speaker: chunkSpeaker,
          });
        }
      }
      return entries;
    }

    async function loadTranscript() {
      if (!transcriptSource || !transcriptSource.url) {
        resetTranscript('No transcript file detected for this project.', 'Missing');
        return;
      }
      if (transcriptStatus) transcriptStatus.textContent = 'Loading‚Ä¶';
      try {
        const response = await fetch(transcriptSource.url);
        if (!response.ok) {
          throw new Error(`HTTP ${response.status}`);
        }
        if (transcriptSource.kind === 'json') {
          const data = await response.json();
          const segments = parseTranscriptJSON(data);
          if (segments.length) {
            renderTranscript(segments);
            updateActiveWord(media.currentTime || 0);
            // Load saved edits after transcript is rendered
            await loadSavedEdits();
          } else {
            resetTranscript('Transcript JSON loaded but no entries were found.', 'Empty');
            return;
          }
        } else {
          const text = await response.text();
          const segments = parseSRT(text);
          renderTranscript(segments);
          updateActiveWord(media.currentTime || 0);
          // Load saved edits after transcript is rendered
          await loadSavedEdits();
        }
      } catch (error) {
        console.error(error);
        resetTranscript(`Unable to load transcript: ${error.message}`, 'Error');
      }
    }

    async function loadNotesTitle() {
      try {
        const response = await fetch('/api/notes');
        if (!response.ok) {
          throw new Error(await response.text());
        }
        const data = await response.json();
    lastNotesContent = data.content || '';
    const currentTitle = extractTitleSection(lastNotesContent) || '';
    guestName = extractSectionFirstLine(lastNotesContent, ['guest']) || '';
    interviewerName = extractSectionFirstLine(lastNotesContent, ['interviewer', 'interviwer']) || '';
    // Load speaker IDs from localStorage
    if (workspaceProjectName) {
      const savedMapping = localStorage.getItem(`speaker-mapping-${workspaceProjectName}`);
      if (savedMapping) {
        try {
          const mapping = JSON.parse(savedMapping);
          // Load the saved values (can be null or number)
          interviewerSpeakerId = mapping.interviewerSpeakerId !== undefined ? mapping.interviewerSpeakerId : 'null';
          guestSpeakerId = mapping.guestSpeakerId !== undefined ? mapping.guestSpeakerId : 'null';
          // Convert to proper dropdown value format (null ‚Üí 'null', number ‚Üí string)
          const interviewerValue = interviewerSpeakerId === null ? 'null' : String(interviewerSpeakerId);
          const guestValue = guestSpeakerId === null ? 'null' : String(guestSpeakerId);
          if (interviewerSpeakerSelect) interviewerSpeakerSelect.value = interviewerValue;
          if (guestSpeakerSelect) guestSpeakerSelect.value = guestValue;
        } catch (e) {
          console.error('Failed to parse speaker mapping:', e);
        }
      }
    }
    updateParticipantDisplay();
    setTitleFormState({ disabled: false, value: currentTitle, status: 'Idle' });
    setParticipantFormState({ disabled: false, interviewer: interviewerName || '', guest: guestName || '', status: 'Idle' });
  } catch (error) {
    console.error(error);
    lastNotesContent = null;
    guestName = '';
    interviewerName = '';
    updateParticipantDisplay();
    setTitleFormState({ disabled: true, value: '', status: 'Notes unavailable' });
    setParticipantFormState({ disabled: true, interviewer: '', guest: '', status: 'Notes unavailable' });
  }
}

    function describe(name) {
      return name || '‚Äî';
    }

    function formatTime(seconds) {
      if (!Number.isFinite(seconds) || seconds < 0) return '--:--:--';
      const hrs = Math.floor(seconds / 3600);
      const mins = Math.floor((seconds % 3600) / 60);
      const secs = Math.floor(seconds % 60);
      return [hrs, mins, secs].map((part) => String(part).padStart(2, '0')).join(':');
    }

    function formatSecondsLabel(seconds) {
      return formatTime(Math.max(0, Number(seconds) || 0));
    }

    function timecodeToSeconds(code) {
      if (typeof code !== 'string') return 0;
      const clean = code.replace(',', '.');
      const parts = clean.split(':').map(Number);
      if (parts.length !== 3 || parts.some((part) => Number.isNaN(part))) {
        return 0;
      }
      const [hrs, mins, secs] = parts;
      return hrs * 3600 + mins * 60 + secs;
    }

    function parseTimecode(value) {
      const match = value.trim().match(/(\d+):(\d+):(\d+)[,\.]?(\d+)?/);
      if (!match) return 0;
      const [, hh, mm, ss, ms = '0'] = match;
      return Number(hh) * 3600 + Number(mm) * 60 + Number(ss) + Number(ms) / 1000;
    }

    function segmentText(text) {
      if (window.Intl && Intl.Segmenter) {
        const segmenter = new Intl.Segmenter(undefined, { granularity: 'word' });
        return Array.from(segmenter.segment(text)).map(({ segment, isWordLike }) => ({
          value: segment,
          isWord: Boolean(isWordLike && segment.trim()),
        }));
      }
      return (text.match(/\S+|\s+/g) || []).map((segment) => ({
        value: segment,
        isWord: Boolean(segment.trim()),
      }));
    }

    function normalizeSegmentTiming(segment) {
      const info = segment.info || resolveSpeakerInfo(segment.speaker);
      const safeText = typeof segment.text === 'string' ? segment.text.trim() : '';
      const startValue = Number(segment.seconds);
      const startSeconds = Number.isFinite(startValue) ? startValue : 0;
      let endValue = Number(segment.endSeconds);
      if (!Number.isFinite(endValue) || endValue <= startSeconds) {
        const tokenCount = safeText ? safeText.split(/\s+/).length : 0;
        const approx = Math.max(tokenCount * 0.32, 0.6);
        endValue = startSeconds + approx;
      }
      const timeLabel = segment.time || formatSecondsLabel(startSeconds);
      return {
        ...segment,
        info,
        text: safeText,
        seconds: startSeconds,
        endSeconds: endValue,
        time: timeLabel,
      };
    }

    function segmentsSeemContinuous(previous, current) {
      const prevEnd = Number(previous.endSeconds ?? previous.seconds ?? 0);
      const gap = Number(current.seconds ?? 0) - prevEnd;
      if (!Number.isFinite(gap)) return false;
      return gap <= MERGE_GAP_SECONDS && gap >= -0.75;
    }

    function mergeSegmentsBySpeaker(segments) {
      const merged = [];
      segments.forEach((segment) => {
        const normalized = normalizeSegmentTiming(segment);
        if (!normalized.text) {
          return;
        }
        const last = merged[merged.length - 1];
        const sameSpeaker =
          last &&
          normalized.info &&
          last.info &&
          ((normalized.speaker === last.speaker) ||
            (normalized.info.role === last.info.role && normalized.info.label === last.info.label));
        if (last && sameSpeaker && segmentsSeemContinuous(last, normalized)) {
          const combined = `${last.text} ${normalized.text}`.trim();
          last.text = combined.replace(/\s+/g, ' ');
          last.endSeconds = Math.max(last.endSeconds, normalized.endSeconds);
          last.rawParts.push(normalized);
        } else {
          const entry = {
            ...normalized,
            rawParts: normalized.rawParts ? [...normalized.rawParts] : [normalized],
          };
          merged.push(entry);
        }
      });
      return merged;
    }

    function updateCurrentTime() {
      if (currentTimeEl) {
        currentTimeEl.textContent = formatTime(media.currentTime || 0);
      }
      updateActiveWord(media.currentTime || 0);
      updateEditedDuration();

      // Auto-skip deleted words during playback
      if (!media.paused && wordSpans.length > 0) {
        const currentTime = media.currentTime;

        // Find the current word index
        const currentWordIndex = wordSpans.findIndex((w, idx) =>
          currentTime >= w.start && currentTime < w.end
        );

        // If we're in a deleted word, skip to the next non-deleted word
        if (currentWordIndex >= 0 && deletedWords.has(currentWordIndex)) {
          const nextWordIndex = wordSpans.findIndex((w, idx) =>
            idx > currentWordIndex && !deletedWords.has(idx)
          );

          if (nextWordIndex >= 0) {
            media.currentTime = wordSpans[nextWordIndex].start;
          } else {
            // No more non-deleted words - pause at end
            media.pause();
          }
        }
      }
    }

    function updateEditedDuration() {
      if (!durationEl || wordSpans.length === 0) return;

      let totalDuration = 0;
      let deletedDuration = 0;

      wordSpans.forEach((word, index) => {
        const duration = word.end - word.start;
        totalDuration += duration;
        if (deletedWords.has(index)) {
          deletedDuration += duration;
        }
      });

      const editedDuration = totalDuration - deletedDuration;
      durationEl.textContent = formatTime(editedDuration);
    }

    function updateStatusLine() {
      if (!statusLine) return;

      if (wordSpans.length === 0) {
        statusLine.textContent = 'No transcript loaded';
        return;
      }

      const totalWords = wordSpans.length;
      const deletedCount = deletedWords.size;

      if (deletedCount === 0) {
        statusLine.textContent = `Editing: ${totalWords} words (no edits yet)`;
      } else {
        const percentage = Math.round((deletedCount / totalWords) * 100);
        statusLine.textContent = `Edited video: ${deletedCount} words removed (${percentage}% cut)`;
      }
    }

    function updateVersionButtons() {
      if (!originalButton || !proxyButton) return;
      originalButton.disabled = !workspaceSources.original;
      proxyButton.disabled = false;
      proxyButton.classList.toggle('pending', !workspaceSources.proxy);
      originalButton.classList.toggle('active', currentSourceRole === 'original');
      proxyButton.classList.toggle('active', currentSourceRole === 'proxy');
    }

    function resetPlayerState(message) {
      media.pause();
      mediaSource.removeAttribute('src');
      media.load();
      if (currentTimeEl) currentTimeEl.textContent = '00:00:00';
      if (durationEl) durationEl.textContent = '--:--:--';
      statusLine.textContent = message;
      updateVersionButtons();
    }

    function configureVideoSource(preferredRole) {
      if (preferredRole) {
        currentSourceRole = preferredRole;
      }
      if (currentSourceRole === 'proxy' && !workspaceSources.proxy) {
        currentSourceRole = workspaceSources.original ? 'original' : 'proxy';
      }
      if (currentSourceRole === 'original' && !workspaceSources.original && workspaceSources.proxy) {
        currentSourceRole = 'proxy';
      }

      const url = workspaceSources[currentSourceRole];
      if (!url) {
        resetPlayerState('Select a project with a video file to begin playback.');
        return;
      }

      const fileName = currentSourceRole === 'proxy' ? workspaceFiles.proxy : workspaceFiles.video;
      const wasPaused = media.paused;
      const previousTime = media.currentTime || 0;
      mediaSource.src = url;
      media.load();
      media.addEventListener(
        'loadedmetadata',
        () => {
          if (durationEl) durationEl.textContent = formatTime(media.duration);
          const safeTime = Math.min(previousTime, Math.max(0, media.duration - 0.2));
          media.currentTime = safeTime;

          // Apply current playback speed
          if (currentSpeed && currentSpeed !== 1.0) {
            media.playbackRate = currentSpeed;
          }

          if (!wasPaused) {
            media.play().catch((error) => {
              console.error('Autoplay failed:', error);
              addLogMessage('Autoplay blocked by browser. Click play to start.', 'info');
            });
          }
          updateCurrentTime();
        },
        { once: true },
      );
      updateStatusLine();
      updateVersionButtons();
    }

    function computeProxyName() {
      const videoName = workspaceFiles.video;
      if (!videoName) return 'proxy.mp4';
      const lastDot = videoName.lastIndexOf('.');
      const ext = lastDot >= 0 ? videoName.slice(lastDot) : '.mp4';
      const base = lastDot >= 0 ? videoName.slice(0, lastDot) : videoName;
      return `${base}_ultralow${ext}`;
    }

    function showLoader(message) {
      if (!conversionLoader) return;
      conversionLoader.classList.remove('hidden');
      if (loaderFill) loaderFill.style.width = '0';
      if (loaderText) loaderText.textContent = message || 'Preparing‚Ä¶';
    }

    function updateLoader(progress, message) {
      if (loaderFill) {
        loaderFill.style.width = `${Math.max(0, Math.min(progress, 100))}%`;
      }
      if (loaderText && message) {
        loaderText.textContent = message;
      }
    }

    function hideLoader() {
      if (!conversionLoader) return;
      conversionLoader.classList.add('hidden');
    }

    async function ensureProxyExists() {
      if (!workspaceInfo || !workspaceInfo.valid) {
        alert('Open a project with the required files first.');
        return false;
      }
      if (!workspaceFiles.video) {
        alert('No source video found in the current workspace.');
        return false;
      }
      if (workspaceFiles.proxy && workspaceSources.proxy) {
        return true;
      }
      const targetName = workspaceFiles.proxy || computeProxyName();
      showLoader('Starting conversion‚Ä¶');
      try {
        const payload = { source: workspaceFiles.video, target: targetName };
        const response = await fetch('/api/create-proxy', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(payload),
        });
        const data = await response.json();
        if (!response.ok) {
          throw new Error(data.error || response.statusText);
        }
        if (data.status === 'exists') {
          hideLoader();
          await loadWorkspace({ refresh: true });
          return true;
        }
        const jobId = data.job_id;
        if (!jobId) {
          hideLoader();
          await loadWorkspace({ refresh: true });
          return true;
        }
        const job = await waitForJob(jobId, (update) => {
          const progress = update.progress ?? (update.status === 'running' ? 50 : 0);
          updateLoader(progress, `${update.message || 'encoding'} (${progress.toFixed(1)}%)`);
        });
        hideLoader();
        if (job.status === 'completed') {
          await loadWorkspace({ refresh: true });
          return true;
        }
        alert(`Proxy conversion failed: ${job.message || 'Unknown error'}`);
        return false;
      } catch (error) {
        console.error(error);
        hideLoader();
        alert(`Proxy conversion failed: ${error.message}`);
        return false;
      }
    }

    async function applyWorkspaceSummary(summary) {
      workspaceInfo = summary;
      workspaceProjectName = summary && summary.project_name ? summary.project_name : null;
      updateLinks(summary?.path);
      updatePageHeader(summary);
      closeCoverPreview();
      if (!summary || !summary.valid) {
        workspaceProjectName = null;
        workspaceFiles = { notes: null, srt: null, video: null, proxy: null, audio: null, transcript_json: null, chapters: null };
        workspaceSources = { original: null, proxy: null };
        currentSourceRole = 'proxy';
      transcriptSource = { kind: null, name: null, url: null };
        guestName = '';
        interviewerName = '';
        speakerMap = new Map();
        updateParticipantDisplay();
        resetPlayerState('Workspace not ready. Make sure the project contains a video file.');
        resetTranscript('Open a project with a transcript to preview it here.');
        lastNotesContent = null;
        setTitleFormState({ disabled: true, value: '', status: 'Open a project from Projects ‚Üí' });
        setParticipantFormState({ disabled: true, interviewer: '', guest: '', status: 'Open a project from Projects ‚Üí' });
        updateDownloadAllState();
        closeFileManager();
        resetScriptStateCache();
        scriptButtons.forEach((button) => applyScriptVisualState(button));
        return;
    }
    workspaceFiles = Object.assign({ notes: null, srt: null, video: null, proxy: null, audio: null, transcript_json: null, chapters: null }, summary.files);
    workspaceSources = {
      original: workspaceUrl(workspaceFiles.video),
      proxy: workspaceUrl(workspaceFiles.proxy),
    };
    loadScriptStateMap(true);
    scriptButtons.forEach((button, scriptName) => {
      applyScriptVisualState(button, getScriptOutcome(scriptName));
    });
      currentSourceRole = workspaceSources.proxy ? 'proxy' : 'original';
      transcriptSource = { kind: null, name: null, url: null };
      if (workspaceFiles.transcript_json) {
        transcriptSource = { kind: 'json', name: workspaceFiles.transcript_json, url: workspaceUrl(workspaceFiles.transcript_json) };
      } else if (workspaceFiles.srt) {
        transcriptSource = { kind: 'srt', name: workspaceFiles.srt, url: workspaceUrl(workspaceFiles.srt) };
      }
      guestName = '';
      interviewerName = '';
      updateParticipantDisplay();
      updateDownloadAllState();
      setTitleFormState({ disabled: true, value: '', status: 'Loading‚Ä¶' });
      setParticipantFormState({ disabled: true, interviewer: '', guest: '', status: 'Loading‚Ä¶' });
      await loadNotesTitle();
      updateParticipantDisplay();
      if (!workspaceSources.original && !workspaceSources.proxy) {
        resetPlayerState('No video found in this project. Upload an MP4 from the Projects page.');
      } else {
        configureVideoSource();
      }
      if (transcriptSource.kind) {
        await loadTranscript();
      } else {
        resetTranscript('No transcript file detected for this project.', 'Missing');
      }
    }

    async function loadWorkspace({ refresh = false } = {}) {
      try {
        const query = refresh ? '?refresh=1' : '';
        const response = await fetch(`/api/workspace${query}`);
        const data = await response.json();
        await applyWorkspaceSummary(data);
      } catch (error) {
        console.error(error);
        statusLine.textContent = `Unable to load workspace: ${error.message}`;
        resetTranscript('Unable to load workspace details.', 'Error');
        setTitleFormState({ disabled: true, value: '', status: 'Workspace error' });
      }
    }

    // Log Bar Management
    const logBar = document.getElementById('log-bar');
    const logBarToggle = document.getElementById('log-bar-toggle');
    const logBarClear = document.getElementById('log-bar-clear');
    const logJobList = document.getElementById('log-job-list');
    const logSummaryText = document.getElementById('log-summary-text');
    const activeJobs = new Map(); // jobId -> { card, logsVisible, lastLogCount }

    logBarToggle.addEventListener('click', () => {
      logBar.classList.toggle('minimized');
    });

    logBarClear.addEventListener('click', (e) => {
      e.stopPropagation();
      // Remove completed and failed jobs
      const toRemove = [];
      activeJobs.forEach((jobData, jobId) => {
        if (jobData.status === 'completed' || jobData.status === 'failed') {
          jobData.card.remove();
          toRemove.push(jobId);
        }
      });
      toRemove.forEach(id => activeJobs.delete(id));
      updateLogBarSummary();
    });

    function updateLogBarSummary() {
      const running = Array.from(activeJobs.values()).filter(j => j.status === 'running').length;
      const completed = Array.from(activeJobs.values()).filter(j => j.status === 'completed').length;
      const failed = Array.from(activeJobs.values()).filter(j => j.status === 'failed').length;
      const pending = Array.from(activeJobs.values()).filter(j => j.status === 'pending').length;

      let summary = [];
      if (running > 0) summary.push(`<span class="log-bar-badge running">${running} Running</span>`);
      if (pending > 0) summary.push(`<span class="log-bar-badge">${pending} Pending</span>`);
      if (completed > 0) summary.push(`<span class="log-bar-badge completed">${completed} Completed</span>`);
      if (failed > 0) summary.push(`<span class="log-bar-badge failed">${failed} Failed</span>`);

      if (summary.length === 0) {
        logSummaryText.textContent = 'No active jobs';
        logBar.classList.add('hidden');
      } else {
        logSummaryText.innerHTML = summary.join(' ');
        logBar.classList.remove('hidden');
      }
    }

    // Add simple log message (not a job card)
    function addLogMessage(message, type = 'info') {
      const logId = `log-msg-${Date.now()}`;
      const card = document.createElement('div');
      card.className = 'log-job-card';
      card.id = logId;

      const header = document.createElement('div');
      header.className = 'log-job-header';

      const title = document.createElement('div');
      title.className = 'log-job-title';
      title.textContent = message;

      const status = document.createElement('div');
      status.className = 'log-job-status';
      status.style.color = type === 'error' ? '#f87171' : type === 'success' ? '#34d399' : '#94a3b8';
      status.textContent = type === 'error' ? 'Error' : type === 'success' ? 'Success' : 'Info';

      header.appendChild(title);
      header.appendChild(status);
      card.appendChild(header);

      logJobList.prepend(card);
      logBar.classList.remove('hidden');

      // Auto-remove after 10 seconds
      setTimeout(() => {
        card.remove();
        if (logJobList.children.length === 0 && activeJobs.size === 0) {
          logBar.classList.add('hidden');
        }
      }, 10000);
    }

    function addJobCard(jobId, label) {
      // Check if job card already exists
      if (activeJobs.has(jobId)) {
        return activeJobs.get(jobId);
      }

      // Create card
      const card = document.createElement('div');
      card.className = 'log-job-card';
      card.id = `log-job-${jobId}`;

      const header = document.createElement('div');
      header.className = 'log-job-header';

      const title = document.createElement('div');
      title.className = 'log-job-title';
      title.textContent = label;

      const status = document.createElement('div');
      status.className = 'log-job-status';
      status.textContent = 'queued';

      header.appendChild(title);
      header.appendChild(status);
      card.appendChild(header);

      const progressBar = document.createElement('div');
      progressBar.className = 'log-job-progress';
      const progressFill = document.createElement('span');
      progressFill.className = 'log-job-progress-fill';
      progressFill.style.width = '0%';
      progressBar.appendChild(progressFill);
      card.appendChild(progressBar);

      const logsContainer = document.createElement('div');
      logsContainer.className = 'log-job-logs';
      card.appendChild(logsContainer);

      const actions = document.createElement('div');
      actions.className = 'log-job-actions';

      const toggleLogsBtn = document.createElement('button');
      toggleLogsBtn.className = 'log-job-action-btn';
      toggleLogsBtn.textContent = 'Show Logs';
      toggleLogsBtn.onclick = () => {
        const isVisible = logsContainer.classList.toggle('visible');
        toggleLogsBtn.textContent = isVisible ? 'Hide Logs' : 'Show Logs';
        jobData.logsVisible = isVisible;
      };
      actions.appendChild(toggleLogsBtn);

      card.appendChild(actions);

      logJobList.prepend(card);

      const jobData = {
        card,
        status: 'pending',
        logsVisible: false,
        lastLogCount: 0,
        statusEl: status,
        progressFill,
        logsContainer,
        toggleLogsBtn,
        startTime: null
      };
      activeJobs.set(jobId, jobData);
      updateLogBarSummary();

      // Keep old jobList for compatibility (hide it with CSS if needed)
      const wrapper = document.createElement('div');
      wrapper.className = 'job-item';
      wrapper.id = `job-${jobId}`;
      wrapper.style.display = 'none'; // Hide old-style job cards
      const statusOld = document.createElement('div');
      const progressInfo = document.createElement('div');
      const progressBarOld = document.createElement('div');
      const progressFillOld = document.createElement('span');
      progressBarOld.appendChild(progressFillOld);
      wrapper.appendChild(statusOld);
      wrapper.appendChild(progressInfo);
      wrapper.appendChild(progressBarOld);
      jobList.prepend(wrapper);

      return { wrapper, status: statusOld, progressFill: progressFillOld, progressInfo };
    }

    async function waitForJob(jobId, onUpdate) {
      while (true) {
        const response = await fetch(`/api/jobs/${jobId}`);
        if (!response.ok) break;
        const job = await response.json();

        // Update log bar card
        updateJobCard(jobId, job);

        if (onUpdate) onUpdate(job);
        if (job.status === 'completed' || job.status === 'failed') {
          return job;
        }
        await new Promise((resolve) => setTimeout(resolve, 800));
      }
      return { status: 'failed', message: 'job not found' };
    }

    function formatTimeRemaining(seconds) {
      if (seconds < 60) {
        return `${Math.round(seconds)}s`;
      } else if (seconds < 3600) {
        const mins = Math.floor(seconds / 60);
        const secs = Math.round(seconds % 60);
        return `${mins}m ${secs}s`;
      } else {
        const hours = Math.floor(seconds / 3600);
        const mins = Math.floor((seconds % 3600) / 60);
        return `${hours}h ${mins}m`;
      }
    }

    function updateJobCard(jobId, job) {
      const jobData = activeJobs.get(jobId);
      if (!jobData) return;

      // Update status
      jobData.status = job.status;

      // Calculate time estimation for running jobs with progress
      let statusText = job.status;
      const progress = job.progress || 0;

      if (job.status === 'running' && progress > 0) {
        // Track start time when job first makes progress
        if (!jobData.startTime && progress > 1) {
          jobData.startTime = Date.now();
        }

        // Calculate time remaining based on elapsed time and progress
        if (jobData.startTime && progress > 1 && progress < 99) {
          const elapsed = (Date.now() - jobData.startTime) / 1000; // seconds
          const estimatedTotal = (elapsed / progress) * 100;
          const timeRemaining = estimatedTotal - elapsed;

          // Only show estimate for proxy jobs (they're the slowest)
          const isProxyJob = job.type === 'proxy' || (job.label && job.label.toLowerCase().includes('proxy'));

          if (isProxyJob && timeRemaining > 3 && timeRemaining < 7200) {
            statusText = `${job.status} ‚Äî ${Math.round(progress)}% (~${formatTimeRemaining(timeRemaining)} left)`;
          } else if (job.message) {
            statusText = `${job.status} ‚Äî ${job.message}`;
          }
        } else if (job.message) {
          statusText = `${job.status} ‚Äî ${job.message}`;
        }
      } else if (job.message) {
        statusText = `${job.status} ‚Äî ${job.message}`;
      }

      jobData.statusEl.textContent = statusText;

      // Update progress
      jobData.progressFill.style.width = `${Math.min(progress, 100)}%`;

      // Update progress fill class based on status
      jobData.progressFill.classList.remove('completed', 'failed');
      if (job.status === 'completed') {
        jobData.progressFill.classList.add('completed');
      } else if (job.status === 'failed') {
        jobData.progressFill.classList.add('failed');
      }

      // Update logs
      if (job.logs && job.logs.length > 0) {
        if (job.logs.length !== jobData.lastLogCount) {
          jobData.logsContainer.innerHTML = '';
          job.logs.forEach(logLine => {
            const logDiv = document.createElement('div');
            logDiv.className = 'log-job-log-line';
            logDiv.textContent = logLine;
            jobData.logsContainer.appendChild(logDiv);
          });
          jobData.lastLogCount = job.logs.length;

          // Auto-scroll to bottom if logs are visible
          if (jobData.logsVisible) {
            jobData.logsContainer.scrollTop = jobData.logsContainer.scrollHeight;
          }
        }

        // Show button if there are logs
        jobData.toggleLogsBtn.style.display = 'inline-block';
      } else {
        jobData.toggleLogsBtn.style.display = 'none';
      }

      updateLogBarSummary();
    }

    async function loadExistingJobs() {
      try {
        const response = await fetch('/api/jobs');
        if (!response.ok) return;
        const jobs = await response.json();

        // Create cards for all jobs
        for (const [jobId, job] of Object.entries(jobs)) {
          // Only show jobs from the last 10 minutes to avoid clutter
          const ageMinutes = (Date.now() / 1000 - (job.created_at || 0)) / 60;
          if (ageMinutes > 10) continue;

          // Create job card if it doesn't exist
          if (!activeJobs.has(jobId)) {
            addJobCard(jobId, job.label || job.type || 'Job');
          }

          // Update with current state
          updateJobCard(jobId, job);

          // Start polling for running jobs
          if (job.status === 'running' || job.status === 'pending') {
            pollJob(jobId);
          }
        }
      } catch (error) {
        console.error('Failed to load existing jobs:', error);
      }
    }

    async function pollJob(jobId) {
      // Poll until job is complete or failed
      while (true) {
        try {
          const response = await fetch(`/api/jobs/${jobId}`);
          if (!response.ok) break;
          const job = await response.json();

          updateJobCard(jobId, job);

          if (job.status === 'completed' || job.status === 'failed') {
            // Refresh workspace when important jobs complete
            if (job.status === 'completed') {
              const isTranscriptionJob = job.label && (
                job.label.includes('transcribe') ||
                job.label.includes('Transcribe') ||
                job.type === 'script' && job.label.includes('Deepgram')
              );
              const isProxyJob = job.type === 'proxy';
              const isAudioJob = job.label && job.label.includes('Extract');

              if (isTranscriptionJob || isProxyJob || isAudioJob) {
                // Refresh workspace to show new files/transcripts
                await loadWorkspace({ refresh: true });
              }
            }
            break;
          }

          await new Promise(resolve => setTimeout(resolve, 1000));
        } catch (error) {
          console.error(`Failed to poll job ${jobId}:`, error);
          break;
        }
      }
    }

    function renderStateKey() {
      if (!workspaceProjectName || !transcriptSource || !transcriptSource.name) return null;
      return `podfree-render-state:${workspaceProjectName}:${transcriptSource.name}`;
    }

    function saveRenderState(type) {
      const key = renderStateKey();
      if (!key) return;

      try {
        const deletedIndices = Array.from(deletedWords).sort((a, b) => a - b);
        const state = {
          deletedIndices: deletedIndices,
          timestamp: Date.now()
        };

        const allStates = JSON.parse(window.localStorage.getItem(key) || '{}');
        allStates[type] = state;
        window.localStorage.setItem(key, JSON.stringify(allStates));
      } catch (error) {
        console.warn('Unable to save render state:', error);
      }
    }

    function loadRenderState() {
      const key = renderStateKey();
      if (!key) return { video: null, audio: null };

      try {
        const raw = window.localStorage.getItem(key);
        if (raw) {
          const allStates = JSON.parse(raw);
          return {
            video: allStates.video || null,
            audio: allStates.audio || null
          };
        }
      } catch (error) {
        console.warn('Unable to load render state:', error);
      }
      return { video: null, audio: null };
    }

    function checkRenderUpToDate(type) {
      const renderStates = loadRenderState();
      const renderState = renderStates[type];

      if (!renderState || !renderState.deletedIndices) return false;

      const currentDeleted = Array.from(deletedWords).sort((a, b) => a - b);
      const savedDeleted = renderState.deletedIndices;

      if (currentDeleted.length !== savedDeleted.length) return false;

      for (let i = 0; i < currentDeleted.length; i++) {
        if (currentDeleted[i] !== savedDeleted[i]) return false;
      }

      return true;
    }

    function scriptStateKey() {
      if (!workspaceInfo || !workspaceInfo.path) return null;
      return `podfree-script-state:${workspaceInfo.path}`;
    }

    function loadScriptStateMap(force = false) {
      const key = scriptStateKey();
      if (!key) {
        scriptStateCache.key = null;
        scriptStateCache.data = {};
        return scriptStateCache.data;
      }
      if (!force && scriptStateCache.key === key) {
        return scriptStateCache.data;
      }
      let parsed = {};
      try {
        const raw = window.localStorage.getItem(key);
        if (raw) {
          const candidate = JSON.parse(raw);
          if (candidate && typeof candidate === 'object') {
            parsed = candidate;
          }
        }
      } catch (error) {
        console.warn('Unable to read stored script state:', error);
      }
      scriptStateCache.key = key;
      scriptStateCache.data = parsed;
      return scriptStateCache.data;
    }

    function persistScriptStateMap() {
      if (!scriptStateCache.key) return;
      try {
        window.localStorage.setItem(scriptStateCache.key, JSON.stringify(scriptStateCache.data));
      } catch (error) {
        console.warn('Unable to persist script state:', error);
      }
    }

    function setScriptOutcome(scriptName, outcome) {
      const map = loadScriptStateMap();
      if (!map) return;
      if (outcome) {
        map[scriptName] = outcome;
      } else {
        delete map[scriptName];
      }
      persistScriptStateMap();
    }

    function getScriptOutcome(scriptName) {
      const map = loadScriptStateMap();
      return map ? map[scriptName] : undefined;
    }

    function resetScriptStateCache() {
      scriptStateCache.key = null;
      scriptStateCache.data = {};
    }

    function applyScriptVisualState(button, outcome) {
      if (!button) return;
      const statusSpan = button.querySelector('.status');
      button.classList.remove('completed', 'failed');
      if (!statusSpan) return;
      if (outcome === 'completed') {
        button.classList.add('completed');
        statusSpan.textContent = 'Done';
      } else if (outcome === 'failed') {
        button.classList.add('failed');
        statusSpan.textContent = 'Failed';
      } else {
        statusSpan.textContent = button.dataset.defaultStatus || 'Idle';
      }
    }

    function coverLabelFromName(name) {
      if (!name) return 'Cover';
      const lowered = String(name).toLowerCase();
      if (lowered.includes('youtube')) return 'YouTube Cover';
      if (lowered.includes('podcast')) return 'Podcast Cover';
      if (lowered.includes('thumb')) return 'Thumbnail';
      return 'Cover';
    }

    function closeCoverPreview() {
      if (!coverPreviewModal) return;
      coverPreviewModal.classList.add('hidden');
      if (coverPreviewBody) {
        coverPreviewBody.textContent = '';
      }
      updateBodyModalState();
    }

    function openCoverPreview(paths) {
      if (!coverPreviewModal || !Array.isArray(paths) || !paths.length) {
        alert('No cover images found yet. Generate them first.');
        return;
      }
      if (!workspaceInfo || !workspaceInfo.path) {
        alert('Open a project before previewing covers.');
        return;
      }
      if (coverPreviewBody) {
        coverPreviewBody.textContent = '';
      }
      let rendered = 0;
      paths.forEach((relative) => {
        const url = workspaceUrl(relative);
        if (!url || !coverPreviewBody) return;
        const card = document.createElement('div');
        card.className = 'cover-card';
        const heading = document.createElement('h3');
        heading.textContent = coverLabelFromName(relative);
        const img = document.createElement('img');
        img.src = url;
        img.alt = heading.textContent;
        img.loading = 'lazy';
        const footer = document.createElement('footer');
        const nameSpan = document.createElement('span');
        nameSpan.textContent = relative;
        const actions = document.createElement('div');
        actions.style.display = 'flex';
        actions.style.gap = '0.4rem';
        const openBtn = document.createElement('button');
        openBtn.type = 'button';
        openBtn.textContent = 'Open';
        openBtn.addEventListener('click', () => {
          window.open(url, '_blank', 'noopener');
        });
        const downloadBtn = document.createElement('button');
        downloadBtn.type = 'button';
        downloadBtn.textContent = 'Download';
        downloadBtn.addEventListener('click', () => {
          triggerDownload(url, relative.split('/').pop());
        });
        actions.appendChild(openBtn);
        actions.appendChild(downloadBtn);
        footer.appendChild(nameSpan);
        footer.appendChild(actions);
        card.appendChild(heading);
        card.appendChild(img);
        card.appendChild(footer);
        coverPreviewBody.appendChild(card);
        rendered += 1;
      });
      if (!rendered) {
        alert('Unable to load covers. They may have been moved or deleted.');
        return;
      }
      coverPreviewModal.classList.remove('hidden');
      updateBodyModalState();
    }

    function isMediaFile(filename) {
      if (!filename) return { isMedia: false, type: null };
      const ext = filename.toLowerCase().split('.').pop();
      const videoExts = ['mp4', 'webm', 'ogg', 'mov', 'avi', 'mkv', 'm4v'];
      const audioExts = ['mp3', 'wav', 'ogg', 'aac', 'm4a', 'flac', 'opus'];
      if (videoExts.includes(ext)) return { isMedia: true, type: 'video' };
      if (audioExts.includes(ext)) return { isMedia: true, type: 'audio' };
      return { isMedia: false, type: null };
    }

    function closeMediaPreview() {
      if (!mediaPreviewModal) return;
      mediaPreviewModal.classList.add('hidden');
      if (mediaPreviewBody) {
        mediaPreviewBody.textContent = '';
      }
      updateBodyModalState();
    }

    function openMediaPreview(filename, url) {
      if (!mediaPreviewModal || !url) return;
      const mediaInfo = isMediaFile(filename);
      if (!mediaInfo.isMedia) return;

      if (mediaPreviewBody) {
        mediaPreviewBody.textContent = '';
      }

      if (mediaPreviewTitle) {
        mediaPreviewTitle.textContent = filename;
      }

      const mediaElement = document.createElement(mediaInfo.type);
      mediaElement.controls = true;
      mediaElement.style.maxWidth = '100%';
      mediaElement.style.maxHeight = '70vh';

      const source = document.createElement('source');
      source.src = url;
      mediaElement.appendChild(source);

      if (mediaPreviewBody) {
        mediaPreviewBody.appendChild(mediaElement);
      }

      mediaPreviewModal.classList.remove('hidden');
      updateBodyModalState();
    }

    async function runScript(scriptName, button) {
      const statusSpan = button.querySelector('.status');
      const scriptLabel = button.dataset.label || scriptName;
      try {
        button.disabled = true;
        button.classList.remove('completed', 'failed', 'pending');
        if (statusSpan) statusSpan.textContent = 'Running‚Ä¶';
        const response = await fetch('/api/run-script', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ script: scriptName }),
        });
        const data = await response.json();
        if (!response.ok) {
          throw new Error(data.error || response.statusText);
        }
        const card = addJobCard(data.job_id, `Run ${scriptLabel}`);
        const job = await waitForJob(data.job_id, (update) => {
          card.status.textContent = `${update.status} ‚Äî ${update.message || ''}`;
          const progress = update.progress ?? (update.status === 'running' ? 50 : 0);
          card.progressFill.style.width = `${Math.min(progress, 100)}%`;
        });
        if (job.status === 'completed') {
          setScriptOutcome(scriptName, 'completed');
          applyScriptVisualState(button, 'completed');
        } else {
          setScriptOutcome(scriptName, 'failed');
          applyScriptVisualState(button, 'failed');
        }
        await loadWorkspace({ refresh: true });
        await loadScripts();
      } catch (error) {
        console.error(error);
        alert(`Failed to run ${scriptName}: ${error.message}`);
        setScriptOutcome(scriptName, 'failed');
        applyScriptVisualState(button, 'failed');
      } finally {
        button.disabled = false;
      }
    }

    function renderScripts(list) {
      loadScriptStateMap();
      toolList.textContent = '';
      scriptButtons.clear();
      
      if (!list.length) {
        const empty = document.createElement('p');
        empty.textContent = 'No scripts found in the Podfree/scripts folder.';
        empty.style.color = 'var(--muted)';
        empty.style.fontSize = '0.85rem';
        toolList.appendChild(empty);
        return;
      }

      // Organize scripts by category
      const categories = {
        'editing': { title: 'Editing', scripts: [] },
        'ai-tools': { title: 'AI Tools', scripts: [] },
        'publishing': { title: 'Publishing', scripts: [] }
      };

      list.forEach((entry) => {
        const { path } = entry;
        const category = path.split('/')[0];
        if (categories[category]) {
          categories[category].scripts.push(entry);
        }
      });

      // Create category boxes
      Object.entries(categories).forEach(([categoryKey, categoryData]) => {
        if (categoryData.scripts.length === 0) return;

        const categoryBox = document.createElement('div');
        categoryBox.className = 'category-box';

        const categoryHeader = document.createElement('div');
        categoryHeader.className = 'category-header';

        const categoryTitle = document.createElement('h3');
        categoryTitle.className = 'category-title';
        categoryTitle.textContent = categoryData.title;

        const playButton = document.createElement('button');
        playButton.className = 'category-play-btn';
        playButton.innerHTML = '‚ñ∂ Run All';
        playButton.addEventListener('click', () => runCategoryScripts(categoryData.scripts));

        categoryHeader.appendChild(categoryTitle);
        categoryHeader.appendChild(playButton);

        const scriptsContainer = document.createElement('div');
        scriptsContainer.className = 'category-scripts';

        categoryData.scripts.forEach((entry) => {
          const { name, path, label, status, outputs = [] } = entry;
          const wrapper = document.createElement('div');
          wrapper.className = 'tool-entry';

          const button = document.createElement('button');
          button.type = 'button';
          button.className = 'tool-button';
          button.dataset.script = name;
          button.dataset.label = label;

          let statusText = 'Idle';
          if (status === 'ready') {
            statusText = 'Ready';
          } else if (status === 'missing') {
            statusText = 'Missing';
          }

          button.dataset.defaultStatus = statusText;
          button.innerHTML = `<span>${label}</span><span class="status">${statusText}</span>`;
          button.addEventListener('click', () => runScript(path, button));
          wrapper.appendChild(button);

          if (outputs && outputs.length) {
            button.title = `Outputs:\n${outputs.join('\n')}`;
            const outputNote = document.createElement('div');
            outputNote.className = 'tool-output';
            outputNote.textContent = `Outputs: ${outputs.join(', ')}`;
            wrapper.appendChild(outputNote);
          }

          if (name === 'generate_covers.py' && outputs && outputs.length) {
            const coverPaths = outputs.slice();
            const previewBtn = document.createElement('button');
            previewBtn.type = 'button';
            previewBtn.className = 'cover-preview-button';
            previewBtn.innerHTML = '<svg viewBox="0 0 24 24" aria-hidden="true"><path d="M4 5a3 3 0 0 1 3-3h10a3 3 0 0 1 3 3v14a2 2 0 0 1-2 2H5a1 1 0 0 1-1-1V5Z" opacity="0.35"/><path d="M16.25 12.25 14.5 14.5l-2-2.25L8 17h10l-1.75-4.75Z" /><circle cx="9" cy="8" r="1.5" /></svg><span>View Covers</span>';
            previewBtn.addEventListener('click', () => openCoverPreview(coverPaths));
            wrapper.appendChild(previewBtn);
          }

          scriptsContainer.appendChild(wrapper);
          scriptButtons.set(name, button);
          const persistedOutcome = getScriptOutcome(name);
          if (persistedOutcome) {
            applyScriptVisualState(button, persistedOutcome);
          } else if (outputs && outputs.length) {
            applyScriptVisualState(button, 'completed');
          } else {
            applyScriptVisualState(button, null);
          }
        });

        categoryBox.appendChild(categoryHeader);
        categoryBox.appendChild(scriptsContainer);
        toolList.appendChild(categoryBox);
      });
    }

    async function runCategoryScripts(scripts) {
      if (!scripts || scripts.length === 0) {
        alert('No scripts to run in this category.');
        return;
      }

      const confirmed = confirm(`Run all ${scripts.length} scripts in this category? This will execute them sequentially.`);
      if (!confirmed) return;

      for (const script of scripts) {
        const { path, name } = script;
        const button = scriptButtons.get(name);
        if (button) {
          await runScript(path, button);
          // Small delay between scripts
          await new Promise(resolve => setTimeout(resolve, 1000));
        }
      }
    }

    async function loadScripts() {
      try {
        const response = await fetch('/api/scripts');
        if (!response.ok) {
          throw new Error(await response.text());
        }
        const data = await response.json();
        renderScripts(data.scripts || []);
      } catch (error) {
        console.error(error);
        alert('Unable to load script list: ' + error.message);
      }
    }

    if (refreshScriptsBtn) {
      refreshScriptsBtn.addEventListener('click', loadScripts);
    }

    if (versionToggle) {
      versionToggle.addEventListener('click', async (event) => {
        const button = event.target.closest('button[data-role]');
        if (!button) return;
        const role = button.dataset.role;
        configureVideoSource(role);
      });
    }

    media.addEventListener('timeupdate', updateCurrentTime);
    media.addEventListener('seeked', () => {
      updateCurrentTime();
      isCurrentlySeeking = false; // Clear seeking flag when seek completes
    });
    media.addEventListener('loadeddata', updateCurrentTime);

    // Start/stop playback tracking for skipping deleted words
    media.addEventListener('play', () => {
      startPlaybackTracking();
    });

    media.addEventListener('pause', () => {
      stopPlaybackTracking();
    });

    // Video error handling
    media.addEventListener('error', (e) => {
      console.error('Video playback error:', media.error);
      if (media.error) {
        console.error('Error code:', media.error.code);
        console.error('Error message:', media.error.message);
      }
      addLogMessage(`Video playback error: ${media.error?.message || 'Unknown error'}`, 'error');
    });

    // Video loading feedback
    media.addEventListener('waiting', () => {
      console.log('Video buffering...');
    });

    media.addEventListener('canplay', () => {
      console.log('Video ready to play');
    });

    media.addEventListener('loadstart', () => {
      console.log('Video loading started');
    });

    media.addEventListener('loadeddata', () => {
      console.log('Video data loaded');
    });

    // Speed selector
    if (speedSelector) {
      speedSelector.addEventListener('click', (e) => {
        const button = e.target.closest('button[data-speed]');
        if (!button) return;

        currentSpeed = parseFloat(button.dataset.speed);

        // Set playback rate immediately if video is ready
        if (media && media.readyState >= 2) {
          media.playbackRate = currentSpeed;
        }

        // Update active state
        speedSelector.querySelectorAll('button').forEach(btn => btn.classList.remove('active'));
        button.classList.add('active');
      });
    }

    // Detect manual scrolling in transcript
    if (transcriptEl) {
      transcriptEl.addEventListener('scroll', () => {
        // User is manually scrolling
        userIsScrolling = true;

        // Clear any existing timeout
        if (scrollTimeout) {
          clearTimeout(scrollTimeout);
        }

        // Re-enable auto-scroll after 3 seconds of no scrolling
        scrollTimeout = setTimeout(() => {
          userIsScrolling = false;
        }, 3000);
      }, { passive: true });
    }

    // Unsaved changes modal
    function showUnsavedChangesModal() {
      return new Promise((resolve) => {
        if (unsavedChangesModal) {
          unsavedChangesModal.classList.remove('hidden');

          const handleSave = async () => {
            cleanup();
            await saveTranscriptEdits();
            resolve('save');
          };

          const handleDiscard = () => {
            cleanup();
            resolve('discard');
          };

          const handleCancel = () => {
            cleanup();
            resolve('cancel');
          };

          const cleanup = () => {
            unsavedSaveBtn.removeEventListener('click', handleSave);
            unsavedDiscardBtn.removeEventListener('click', handleDiscard);
            unsavedCancelBtn.removeEventListener('click', handleCancel);
            unsavedChangesModal.classList.add('hidden');
          };

          unsavedSaveBtn.addEventListener('click', handleSave);
          unsavedDiscardBtn.addEventListener('click', handleDiscard);
          unsavedCancelBtn.addEventListener('click', handleCancel);
        } else {
          resolve('discard');
        }
      });
    }

    // Intercept navigation links to check for unsaved changes
    document.querySelectorAll('.nav-link, #logout-link').forEach(link => {
      link.addEventListener('click', async (event) => {
        if (hasUnsavedChanges) {
          event.preventDefault();
          const targetHref = link.getAttribute('href');
          const result = await showUnsavedChangesModal();
          if (result === 'save' || result === 'discard') {
            // Allow navigation after save or discard
            if (link.id === 'logout-link') {
              handleLogout();
            } else {
              window.location.href = targetHref;
            }
          }
          // If 'cancel', do nothing (stay on page)
        }
      });
    });

    // Edit control event listeners
    if (selectionModeBtn) {
      selectionModeBtn.addEventListener('click', () => {
        toggleSelectionMode();
        if (selectionMode) {
          selectionModeBtn.classList.add('active');
        } else {
          selectionModeBtn.classList.remove('active');
        }
      });
    }

    if (deleteSelectedBtn) {
      deleteSelectedBtn.addEventListener('click', deleteSelectedWords);
    }

    if (restoreSelectedBtn) {
      restoreSelectedBtn.addEventListener('click', restoreSelectedWords);
    }

    if (skipDeletedBtn) {
      skipDeletedBtn.addEventListener('click', skipToNextNonDeleted);
    }

    if (saveEditsBtn) {
      saveEditsBtn.addEventListener('click', saveTranscriptEdits);
    }

    if (exportVideoBtn) {
      exportVideoBtn.addEventListener('click', exportEditedVideo);
    }

    if (exportAudioBtn) {
      exportAudioBtn.addEventListener('click', exportEditedAudio);
    }

    if (titleForm) {
      titleForm.addEventListener('submit', async (event) => {
        event.preventDefault();
        if (!titleInput || !titleSave) return;
        const newTitle = titleInput.value.trim();
        if (!newTitle) {
          setTitleFormState({ disabled: false, value: '', status: 'Title cannot be empty' });
          return;
        }
        if (!lastNotesContent) {
          await loadNotesTitle();
          if (!lastNotesContent) {
            setTitleFormState({ disabled: true, value: newTitle, status: 'Notes unavailable' });
            return;
          }
        }
        setTitleFormState({ disabled: true, value: newTitle, status: 'Saving‚Ä¶' });
        try {
          const updated = replaceTitleSection(lastNotesContent, newTitle);
          const response = await fetch('/api/notes', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ content: updated }),
          });
          if (!response.ok) {
            throw new Error(await response.text());
          }
          const data = await response.json();
          lastNotesContent = updated;
          const savedTitle = extractTitleSection(updated);
          setTitleFormState({ disabled: false, value: savedTitle, status: `Saved at ${new Date().toLocaleTimeString()}` });
        } catch (error) {
          console.error(error);
          setTitleFormState({ disabled: false, value: newTitle, status: 'Save failed' });
          alert('Unable to update title: ' + error.message);
        }
      });
    }

    setTitleFormState({ disabled: true, value: '', status: 'Open a project from Projects ‚Üí' });

    // Check session on page load
    async function checkSessionOnLoad() {
      try {
        const response = await originalFetch('/api/workspace');
        if (response.status === 401) {
          redirectToLogin();
          return false;
        }
        return true;
      } catch (error) {
        console.error('Session check failed:', error);
        return false;
      }
    }

    (async () => {
      const sessionValid = await checkSessionOnLoad();
      if (!sessionValid) return;

      await applyWorkspaceFromQuery();
      await applyPendingWorkspace();
      await loadWorkspace();
      await loadScripts();
      await loadExistingJobs();

      // Poll for new jobs every 3 seconds to catch jobs created after upload
      setInterval(() => loadExistingJobs(), 3000);
    })();

    // Warn user about unsaved changes before leaving the page
    window.addEventListener('beforeunload', (event) => {
      if (hasUnsavedChanges) {
        event.preventDefault();
        event.returnValue = ''; // Chrome requires returnValue to be set
        return ''; // For older browsers
      }
    });
  </script>
</body>
</html>
