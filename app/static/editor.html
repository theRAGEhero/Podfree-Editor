<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Podfree Editor</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="icon" href="favicon.ico" />
  <style>
    :root {
      color-scheme: light dark;
      --bg: #0f172a;
      --panel: rgba(15, 23, 42, 0.8);
      --panel-border: rgba(148, 163, 184, 0.18);
      --text: #f8fafc;
      --muted: #94a3b8;
      --accent: #38bdf8;
      font-family: "Inter", "Segoe UI", system-ui, -apple-system, sans-serif;
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      min-height: 100vh;
      background: radial-gradient(circle at top left, rgba(56, 189, 248, 0.18), transparent 55%),
                  radial-gradient(circle at bottom right, rgba(244, 114, 182, 0.1), transparent 58%),
                  var(--bg);
      color: var(--text);
      display: flex;
      flex-direction: column;
      gap: 1.5rem;
      padding: 1.5rem clamp(1rem, 2vw, 2.5rem) 2.5rem;
    }

    header {
      max-width: 960px;
      margin: 0 auto;
      width: 100%;
      display: flex;
      flex-direction: column;
      gap: 0.75rem;
    }

    .brand-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 1rem;
      flex-wrap: wrap;
    }

    .brand-actions {
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    body.modal-open {
      overflow: hidden;
    }

    .icon-button {
      border: 1px solid rgba(148, 163, 184, 0.3);
      background: rgba(148, 163, 184, 0.18);
      color: var(--text);
      display: inline-flex;
      align-items: center;
      justify-content: center;
      padding: 0.4rem 0.55rem;
      border-radius: 10px;
      cursor: pointer;
      gap: 0.4rem;
      transition: background 0.2s ease, color 0.2s ease, transform 0.18s ease;
    }

    .icon-button:hover {
      background: rgba(56, 189, 248, 0.26);
      color: var(--text);
      transform: translateY(-1px);
    }

    .icon-button svg {
      width: 20px;
      height: 20px;
      fill: currentColor;
    }

    .icon-button.small {
      padding: 0.25rem;
      border-radius: 8px;
      gap: 0;
    }

    .icon-button.with-label {
      padding: 0.4rem 0.75rem;
      font-size: 0.85rem;
      letter-spacing: 0.04em;
      text-transform: uppercase;
    }

    .icon-button.with-label span {
      font-size: 0.78rem;
      color: var(--text);
    }


    .site-logo {
      height: 48px;
    }

    .top-nav {
      display: inline-flex;
      gap: 0.5rem;
      background: rgba(15, 23, 42, 0.6);
      border: 1px solid rgba(148, 163, 184, 0.2);
      border-radius: 999px;
      padding: 0.35rem;
    }

    .nav-link {
      color: var(--muted);
      text-decoration: none;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      font-size: 0.76rem;
      padding: 0.35rem 0.9rem;
      border-radius: 999px;
      transition: background 0.2s ease, color 0.2s ease;
    }

    .nav-link:hover {
      background: rgba(148, 163, 184, 0.25);
      color: var(--text);
    }

    .nav-link.active {
      background: var(--accent);
      color: #0b1120;
      font-weight: 600;
    }

    h1 {
      margin: 0;
      font-size: clamp(1.9rem, 1.2rem + 2vw, 2.6rem);
    }

    .info {
      color: var(--muted);
      font-size: 0.95rem;
      margin: 0;
    }

    .title-form {
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
      margin-top: 0.5rem;
    }

    .title-form label {
      font-size: 0.82rem;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      color: var(--muted);
    }

    .title-row {
      display: flex;
      gap: 0.5rem;
      align-items: center;
      flex-wrap: wrap;
    }

    #title-input {
      flex: 1 1 280px;
      min-width: 220px;
      padding: 0.55rem 0.75rem;
      border-radius: 10px;
      border: 1px solid rgba(148, 163, 184, 0.3);
      background: rgba(15, 23, 42, 0.7);
      color: var(--text);
      font-size: 0.95rem;
    }

    #title-input:disabled {
      opacity: 0.6;
      cursor: wait;
    }

    #title-save {
      border: 1px solid rgba(148, 163, 184, 0.3);
      background: rgba(148, 163, 184, 0.18);
      color: var(--text);
      font-size: 0.85rem;
      padding: 0.5rem 0.95rem;
      border-radius: 10px;
      cursor: pointer;
      transition: background 0.2s ease;
    }

    #title-save:hover:not(:disabled) {
      background: rgba(56, 189, 248, 0.26);
    }

    #title-save:disabled {
      opacity: 0.6;
      cursor: wait;
    }

    .title-status {
      font-size: 0.82rem;
      color: var(--muted);
    }

    .participant-form {
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
      margin-top: 0.5rem;
    }

    .participant-form label {
      font-size: 0.82rem;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      color: var(--muted);
    }

    .participant-row {
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      gap: 0.5rem;
    }

    .participant-row input {
      flex: 1 1 200px;
      min-width: 180px;
      padding: 0.5rem 0.7rem;
      border-radius: 10px;
      border: 1px solid rgba(148, 163, 184, 0.3);
      background: rgba(15, 23, 42, 0.7);
      color: var(--text);
      font-size: 0.9rem;
    }

    .participant-row input:disabled {
      opacity: 0.6;
      cursor: wait;
    }

    #participant-save {
      border: 1px solid rgba(148, 163, 184, 0.3);
      background: rgba(148, 163, 184, 0.18);
      color: var(--text);
      font-size: 0.85rem;
      padding: 0.5rem 0.95rem;
      border-radius: 10px;
      cursor: pointer;
      transition: background 0.2s ease;
    }

    #participant-save:hover:not(:disabled) {
      background: rgba(56, 189, 248, 0.26);
    }

    #participant-save:disabled {
      opacity: 0.6;
      cursor: wait;
    }

    .participant-status {
      font-size: 0.82rem;
      color: var(--muted);
    }

    .participant-info {
      display: flex;
      gap: 0.6rem;
      flex-wrap: wrap;
      margin-top: 0.5rem;
    }

    .participant-pill {
      display: inline-flex;
      align-items: center;
      gap: 0.35rem;
      border-radius: 999px;
      padding: 0.35rem 0.85rem;
      font-size: 0.82rem;
      letter-spacing: 0.05em;
      text-transform: uppercase;
      border: 1px solid rgba(148, 163, 184, 0.28);
      background: rgba(148, 163, 184, 0.16);
      color: var(--muted);
    }

    .participant-pill strong {
      color: var(--text);
      font-weight: 600;
      letter-spacing: 0.08em;
    }

    .participant-pill.interviewer {
      border-color: rgba(56, 189, 248, 0.4);
      background: rgba(56, 189, 248, 0.18);
    }

    .participant-pill.guest {
      border-color: rgba(74, 222, 128, 0.4);
      background: rgba(74, 222, 128, 0.18);
    }

    .participant-pill.missing {
      border-color: rgba(148, 163, 184, 0.2);
      background: rgba(148, 163, 184, 0.12);
      color: rgba(148, 163, 184, 0.8);
    }

    .participant-info.all-missing .participant-pill {
      opacity: 0.65;
    }

    .layout {
      flex: 1;
      display: flex;
      flex-wrap: wrap;
      gap: 1.5rem;
      width: 100%;
      max-width: 1140px;
      margin: 0 auto;
    }

    .panel {
      background: var(--panel);
      border: 1px solid var(--panel-border);
      border-radius: 24px;
      padding: clamp(1.2rem, 1rem + 1vw, 1.8rem);
      display: flex;
      flex-direction: column;
      gap: 1rem;
    }

    .player-panel {
      flex: 1 1 580px;
      min-width: 320px;
      position: relative;
    }

    .toolbox {
      flex: 0 0 280px;
      min-width: 260px;
      gap: 1rem;
    }

    .transcript-panel {
      flex: 1 1 420px;
      min-width: 340px;
      max-height: 76vh;
      gap: 1.2rem;
    }

    .transcript-scroll {
      display: flex;
      flex-direction: column;
      gap: 1rem;
      overflow-y: auto;
      padding-right: 0.4rem;
      line-height: 1.6;
      color: var(--text);
      max-height: calc(76vh - 4rem);
    }

    .transcript-entry {
      display: flex;
      flex-direction: column;
      gap: 0.45rem;
      max-width: 70%;
      padding: 0.75rem 1rem;
      border-radius: 16px;
      background: rgba(148, 163, 184, 0.16);
      box-shadow: 0 12px 24px rgba(15, 23, 42, 0.18);
    }

    .transcript-entry p {
      margin: 0;
      color: var(--text);
      font-size: 0.94rem;
      line-height: 1.6;
    }

    .transcript-entry .transcript-meta {
      font-size: 0.76rem;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      color: var(--muted);
    }

    .transcript-entry time {
      font-size: inherit;
      color: inherit;
      background: transparent;
      padding: 0;
      margin: 0;
    }

    .transcript-entry.speaker-interviewer {
      background: rgba(56, 189, 248, 0.22);
      align-self: flex-start;
    }

    .transcript-entry.speaker-guest {
      background: rgba(74, 222, 128, 0.22);
      align-self: flex-end;
    }

    .transcript-entry.speaker-guest .transcript-meta {
      text-align: right;
    }

    .transcript-entry.speaker-guest p {
      text-align: left;
    }

    .transcript-entry.speaker-narration {
      background: rgba(148, 163, 184, 0.16);
      align-self: center;
    }

    .transcript-entry.speaker-other {
      background: rgba(148, 163, 184, 0.16);
    }

    video {
      width: 100%;
      border-radius: 16px;
      background: #020617;
      box-shadow: 0 18px 44px rgba(15, 23, 42, 0.4);
    }

    .loader-overlay {
      position: absolute;
      inset: 1.5rem 1.5rem auto;
      background: rgba(15, 23, 42, 0.94);
      border: 1px solid rgba(148, 163, 184, 0.22);
      border-radius: 18px;
      padding: 1rem 1.2rem;
      display: flex;
      flex-direction: column;
      gap: 0.65rem;
      box-shadow: 0 24px 64px rgba(15, 23, 42, 0.5);
      z-index: 5;
    }

    .loader-overlay.hidden {
      display: none;
    }

    .loader-title {
      margin: 0;
      font-size: 0.9rem;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      color: var(--muted);
    }

    .loader-bar {
      height: 6px;
      border-radius: 999px;
      background: rgba(148, 163, 184, 0.2);
      overflow: hidden;
    }

    .loader-bar__fill {
      height: 100%;
      width: 0;
      border-radius: inherit;
      background: linear-gradient(90deg, var(--accent), #0ea5e9);
      transition: width 0.18s ease;
    }

    .loader-text {
      margin: 0;
      font-size: 0.85rem;
      color: var(--muted);
    }

    .media-meta {
      display: flex;
      justify-content: space-between;
      font-size: 0.86rem;
      color: var(--muted);
      align-items: center;
    }

    .transcript-header {
      display: flex;
      justify-content: space-between;
      align-items: baseline;
      gap: 1rem;
    }

    .transcript-header h2 {
      margin: 0;
      font-size: 1rem;
      text-transform: uppercase;
      letter-spacing: 0.12em;
      color: var(--muted);
    }

    .status-badge {
      font-size: 0.75rem;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: var(--accent);
      border: 1px solid var(--accent);
      border-radius: 999px;
      padding: 0.25rem 0.75rem;
    }


    .version-toggle {
      display: inline-flex;
      background: rgba(148, 163, 184, 0.16);
      border-radius: 999px;
      padding: 0.4rem;
      gap: 0.4rem;
    }

    .version-toggle button {
      border: none;
      border-radius: 999px;
      padding: 0.4rem 1rem;
      background: transparent;
      color: var(--muted);
      font-size: 0.82rem;
      letter-spacing: 0.06em;
      text-transform: uppercase;
      cursor: pointer;
      transition: background-color 0.2s ease, color 0.2s ease;
    }

    .version-toggle button:hover {
      background: rgba(148, 163, 184, 0.22);
    }

    .version-toggle button.active {
      background: var(--accent);
      color: #0b1120;
      font-weight: 600;
      box-shadow: 0 8px 18px rgba(56, 189, 248, 0.2);
    }

    .version-toggle button.pending {
      opacity: 0.75;
    }

    .version-toggle button:disabled {
      opacity: 0.45;
      cursor: wait;
    }

    .status {
      color: var(--muted);
      font-size: 0.9rem;
    }

    .word {
      cursor: pointer;
      transition: background 0.16s ease, color 0.16s ease;
      border-radius: 6px;
      padding: 0 0.18rem;
      margin: 0 -0.05rem;
    }

    .word:hover {
      background: rgba(148, 163, 184, 0.2);
    }

    .word.active {
      background: rgba(56, 189, 248, 0.28);
      color: var(--text);
      box-shadow: 0 0 0 1px rgba(56, 189, 248, 0.4);
    }

    .links,
    .toolbox-header {
      display: flex;
      gap: 0.75rem;
      flex-wrap: wrap;
      align-items: center;
    }

    .links a,
    .toolbox-refresh {
      border: 1px solid rgba(148, 163, 184, 0.3);
      border-radius: 999px;
      padding: 0.45rem 1rem;
      text-decoration: none;
      color: var(--text);
      font-size: 0.85rem;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      transition: background 0.2s ease, border 0.2s ease;
    }

    .links a:hover,
    .toolbox-refresh:hover {
      background: rgba(56, 189, 248, 0.22);
      border-color: rgba(56, 189, 248, 0.4);
    }

    .toolbox-refresh {
      background: rgba(15, 23, 42, 0.5);
      cursor: pointer;
      line-height: 1;
    }

    .tool-list {
      display: flex;
      flex-direction: column;
      gap: 1rem;
    }

    .category-box {
      border: 1px solid rgba(148, 163, 184, 0.2);
      border-radius: 12px;
      overflow: hidden;
      background: rgba(148, 163, 184, 0.05);
    }

    .category-header {
      background: rgba(148, 163, 184, 0.1);
      padding: 0.75rem 1rem;
      display: flex;
      justify-content: space-between;
      align-items: center;
      border-bottom: 1px solid rgba(148, 163, 184, 0.15);
    }

    .category-title {
      font-size: 0.85rem;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: var(--text);
      margin: 0;
    }

    .category-play-btn {
      background: rgba(56, 189, 248, 0.2);
      border: 1px solid rgba(56, 189, 248, 0.4);
      border-radius: 8px;
      padding: 0.4rem 0.8rem;
      color: var(--text);
      cursor: pointer;
      font-size: 0.8rem;
      font-weight: 500;
      transition: all 0.2s ease;
      display: flex;
      align-items: center;
      gap: 0.4rem;
    }

    .category-play-btn:hover {
      background: rgba(56, 189, 248, 0.3);
      border-color: rgba(56, 189, 248, 0.6);
    }

    .category-play-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .category-scripts {
      padding: 0.8rem;
      display: flex;
      flex-direction: column;
      gap: 0.6rem;
    }

    .tool-button {
      border: 1px solid rgba(148, 163, 184, 0.24);
      background: rgba(148, 163, 184, 0.14);
      border-radius: 14px;
      padding: 0.55rem 0.8rem;
      color: var(--text);
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 0.6rem;
      cursor: pointer;
      transition: background 0.2s ease, border 0.2s ease;
      font-size: 0.88rem;
    }

    .tool-button:hover {
      background: rgba(56, 189, 248, 0.18);
      border-color: rgba(56, 189, 248, 0.4);
    }

    .tool-button .status {
      font-size: 0.78rem;
      color: rgba(148, 163, 184, 0.9);
    }

    .tool-button.completed {
      border-color: rgba(74, 222, 128, 0.45);
      background: rgba(74, 222, 128, 0.16);
    }

    .tool-button.completed .status::before {
      content: "✔ ";
      color: #4ade80;
    }

    .tool-button.failed {
      border-color: rgba(248, 113, 113, 0.45);
      background: rgba(248, 113, 113, 0.16);
    }

    .tool-button.failed .status::before {
      content: "⚠ ";
      color: #f87171;
    }

    .tool-button.pending {
      border-color: rgba(248, 113, 113, 0.45);
      background: rgba(248, 113, 113, 0.16);
    }

    .tool-entry {
      display: flex;
      flex-direction: column;
      gap: 0.35rem;
    }

    .cover-preview-button {
      align-self: flex-start;
      display: inline-flex;
      align-items: center;
      gap: 0.4rem;
      padding: 0.4rem 0.65rem;
      border-radius: 10px;
      border: 1px solid rgba(148, 163, 184, 0.26);
      background: rgba(148, 163, 184, 0.12);
      color: var(--text);
      font-size: 0.78rem;
      letter-spacing: 0.04em;
      text-transform: uppercase;
      cursor: pointer;
      transition: background 0.2s ease, border 0.2s ease, transform 0.18s ease;
    }

    .cover-preview-button:hover {
      background: rgba(56, 189, 248, 0.2);
      border-color: rgba(56, 189, 248, 0.4);
      transform: translateY(-1px);
    }

    .cover-preview-button svg {
      width: 18px;
      height: 18px;
      fill: currentColor;
    }

    .cover-modal.hidden {
      display: none;
    }

    .cover-modal {
      position: fixed;
      inset: 0;
      z-index: 3200;
      background: rgba(15, 23, 42, 0.76);
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 1.5rem;
    }

    .cover-modal-dialog {
      width: min(720px, 96vw);
      background: rgba(15, 23, 42, 0.92);
      border: 1px solid rgba(148, 163, 184, 0.25);
      border-radius: 20px;
      display: flex;
      flex-direction: column;
      gap: 1rem;
      padding: 1.2rem;
      box-shadow: 0 30px 80px rgba(15, 23, 42, 0.6);
    }

    .cover-modal-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 0.8rem;
    }

    .cover-modal-header h2 {
      margin: 0;
      font-size: 1rem;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      color: var(--muted);
    }

    .cover-modal-body {
      display: grid;
      gap: 1rem;
      grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
    }

    .cover-card {
      background: rgba(15, 23, 42, 0.72);
      border: 1px solid rgba(148, 163, 184, 0.2);
      border-radius: 16px;
      padding: 0.75rem;
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
    }

    .cover-card h3 {
      margin: 0;
      font-size: 0.85rem;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: var(--muted);
    }

    .cover-card img {
      width: 100%;
      border-radius: 12px;
      border: 1px solid rgba(148, 163, 184, 0.18);
      box-shadow: 0 10px 26px rgba(15, 23, 42, 0.45);
    }

    .cover-card footer {
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-size: 0.75rem;
      color: var(--muted);
    }

    .cover-card footer button {
      border: 1px solid rgba(148, 163, 184, 0.3);
      background: rgba(148, 163, 184, 0.16);
      color: var(--text);
      border-radius: 8px;
      padding: 0.35rem 0.6rem;
      font-size: 0.72rem;
      letter-spacing: 0.04em;
      text-transform: uppercase;
      cursor: pointer;
      transition: background 0.2s ease, border 0.2s ease;
    }

    .cover-card footer button:hover {
      background: rgba(56, 189, 248, 0.22);
      border-color: rgba(56, 189, 248, 0.4);
    }

    .tool-output {
      font-size: 0.78rem;
      color: var(--muted);
      margin-left: 0.25rem;
    }

    .job-list {
      display: flex;
      flex-direction: column;
      gap: 0.6rem;
      max-height: 220px;
      overflow-y: auto;
      padding-right: 0.3rem;
    }

    .job-item {
      background: rgba(15, 23, 42, 0.75);
      border: 1px solid rgba(148, 163, 184, 0.22);
      border-radius: 14px;
      padding: 0.65rem 0.8rem;
      display: flex;
      flex-direction: column;
      gap: 0.45rem;
    }

    .job-item h3 {
      margin: 0;
      font-size: 0.9rem;
      color: rgba(241, 245, 249, 0.88);
    }

    .job-status {
      font-size: 0.78rem;
      color: var(--muted);
    }

    .job-progress {
      height: 4px;
      border-radius: 999px;
      background: rgba(148, 163, 184, 0.22);
      overflow: hidden;
    }

    .job-progress span {
      display: block;
      height: 100%;
      width: 0;
      background: linear-gradient(90deg, var(--accent), #0ea5e9);
      transition: width 0.2s ease;
    }

    .file-modal.hidden {
      display: none;
    }

    .file-modal {
      position: fixed;
      inset: 0;
      background: rgba(15, 23, 42, 0.72);
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 1.5rem;
      z-index: 3000;
    }

    .file-modal-dialog {
      background: rgba(15, 23, 42, 0.92);
      border: 1px solid rgba(148, 163, 184, 0.25);
      border-radius: 18px;
      width: min(780px, 95vw);
      max-height: 90vh;
      display: flex;
      flex-direction: column;
      box-shadow: 0 24px 60px rgba(15, 23, 42, 0.55);
      overflow: hidden;
    }

    .file-modal-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 1rem 1.25rem 0.75rem;
      border-bottom: 1px solid rgba(148, 163, 184, 0.18);
      gap: 1rem;
    }

    .file-modal-header h2 {
      margin: 0;
      font-size: 1rem;
      letter-spacing: 0.08em;
      text-transform: uppercase;
    }

    .file-modal-path {
      margin: 0.2rem 0 0;
      font-size: 0.8rem;
      color: var(--muted);
    }

    .file-modal-body {
      padding: 1rem 1.25rem 1.25rem;
      display: flex;
      flex-direction: column;
      gap: 0.9rem;
      overflow: hidden;
    }

    .file-toolbar {
      display: flex;
      flex-wrap: wrap;
      gap: 0.6rem;
      align-items: center;
    }

    .file-toolbar button {
      border: 1px solid rgba(148, 163, 184, 0.3);
      background: rgba(148, 163, 184, 0.18);
      color: var(--text);
      font-size: 0.8rem;
      padding: 0.45rem 0.85rem;
      border-radius: 10px;
      cursor: pointer;
      transition: background 0.2s ease;
    }

    .file-toolbar button:hover:not(:disabled) {
      background: rgba(56, 189, 248, 0.26);
    }

    .file-toolbar button:disabled {
      opacity: 0.6;
      cursor: default;
    }

    .file-toolbar label {
      border: 1px solid rgba(148, 163, 184, 0.3);
      border-radius: 10px;
      padding: 0.45rem 0.85rem;
      color: var(--text);
      font-size: 0.8rem;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      background: rgba(148, 163, 184, 0.18);
      cursor: pointer;
      transition: background 0.2s ease;
      display: inline-flex;
      align-items: center;
      gap: 0.35rem;
    }

    .file-toolbar label:hover {
      background: rgba(56, 189, 248, 0.26);
    }

    #file-upload-input {
      display: none;
    }

    .file-selection-count {
      font-size: 0.78rem;
      color: var(--muted);
    }

    .file-breadcrumbs {
      display: flex;
      flex-wrap: wrap;
      gap: 0.35rem;
      font-size: 0.78rem;
      color: var(--muted);
    }

    .file-breadcrumbs button {
      border: none;
      background: transparent;
      color: inherit;
      font: inherit;
      cursor: pointer;
      padding: 0.1rem 0.35rem;
      border-radius: 6px;
      transition: background 0.2s ease;
    }

    .file-breadcrumbs button:hover {
      background: rgba(148, 163, 184, 0.18);
      color: var(--text);
    }

    .file-list {
      border: 1px solid rgba(148, 163, 184, 0.22);
      border-radius: 14px;
      background: rgba(15, 23, 42, 0.6);
      overflow: hidden;
      display: flex;
      flex-direction: column;
      max-height: 45vh;
    }

    .file-header,
    .file-row {
      display: grid;
      grid-template-columns: 32px 1fr 90px 130px 120px;
      gap: 0.6rem;
      align-items: center;
      padding: 0.55rem 0.85rem;
    }

    .file-header {
      font-size: 0.74rem;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      color: var(--muted);
      border-bottom: 1px solid rgba(148, 163, 184, 0.18);
    }

    .file-rows {
      overflow: auto;
    }

    .file-row {
      border-bottom: 1px solid rgba(148, 163, 184, 0.12);
      font-size: 0.85rem;
      transition: background 0.15s ease;
    }

    .file-row:last-child {
      border-bottom: none;
    }

    .file-row.selected {
      background: rgba(56, 189, 248, 0.16);
    }

    .file-row.directory .file-name {
      color: var(--text);
    }

    .file-name {
      border: none;
      background: transparent;
      color: var(--muted);
      font: inherit;
      text-align: left;
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      gap: 0.45rem;
    }

    .file-name:hover {
      color: var(--text);
    }

    .file-name svg {
      width: 18px;
      height: 18px;
      fill: currentColor;
    }

    .file-actions {
      display: inline-flex;
      gap: 0.35rem;
    }

    .file-actions button {
      border: 1px solid rgba(148, 163, 184, 0.25);
      background: rgba(148, 163, 184, 0.12);
      color: var(--text);
      font-size: 0.72rem;
      padding: 0.35rem 0.6rem;
      border-radius: 8px;
      cursor: pointer;
      transition: background 0.2s ease;
    }

    .file-actions button:hover:not(:disabled) {
      background: rgba(56, 189, 248, 0.22);
    }

    .file-actions button:disabled {
      opacity: 0.55;
      cursor: default;
    }

    .file-row input[type="checkbox"] {
      width: 16px;
      height: 16px;
      cursor: pointer;
    }

    .file-status {
      font-size: 0.78rem;
      color: var(--muted);
      margin: 0;
    }

    .file-empty-message {
      padding: 1.2rem;
      text-align: center;
      color: var(--muted);
      font-size: 0.85rem;
    }

    @media (max-width: 960px) {
      .toolbox {
        flex: 1 1 100%;
      }
      .transcript-panel {
        max-height: none;
      }
      .transcript-scroll {
        max-height: none;
      }
    }
  </style>
</head>
<body>
  <header>
    <div class="brand-row">
      <img src="logo.svg" alt="Podfree" class="site-logo" />
      <div class="brand-actions">
        <nav class="top-nav">
          <a class="nav-link" href="projects.html">Projects</a>
          <a class="nav-link active" href="editor.html">Editor</a>
          <a class="nav-link" href="light_editor.html">Video</a>
          <a class="nav-link" href="notes_editor.html">Notes</a>
          <a class="nav-link" href="#" id="logout-link">Logout</a>
        </nav>
        <button id="file-manager-button" class="icon-button with-label" type="button" title="Manage workspace files">
          <svg viewBox="0 0 24 24" aria-hidden="true">
            <path d="M4 6a2 2 0 0 1 2-2h4.172a2 2 0 0 1 1.414.586L12.828 6H18a2 2 0 0 1 2 2v9a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6Z" />
            <path d="M8 11h8v2H8z" fill="currentColor" />
          </svg>
          <span>Files</span>
        </button>
      </div>
    </div>
    <h1 id="page-title">Edit Project</h1>
    <form id="title-form" class="title-form">
      <label for="title-input">Title</label>
      <div class="title-row">
        <input id="title-input" type="text" placeholder="Title will appear here" disabled />
        <button id="title-save" type="submit" disabled>Save</button>
        <span id="title-status" class="title-status">Idle</span>
      </div>
    </form>
    <form id="participant-form" class="participant-form">
      <label for="interviewer-input">Participants</label>
      <div class="participant-row">
        <input id="interviewer-input" type="text" placeholder="Interviewer name" disabled />
        <input id="guest-input" type="text" placeholder="Guest name" disabled />
        <button id="participant-save" type="submit" disabled>Save</button>
        <span id="participant-status" class="participant-status">Open a project from Projects →</span>
      </div>
    </form>
  </header>

  <main class="layout">
    <section class="panel player-panel">
      <video id="media" controls preload="metadata">
        <source id="media-source" type="video/mp4" />
        Your browser does not support HTML video.
      </video>
      <div id="conversion-loader" class="loader-overlay hidden">
        <p class="loader-title">Preparing lightweight copy…</p>
        <div class="loader-bar"><div id="loader-progress" class="loader-bar__fill"></div></div>
        <p id="loader-text" class="loader-text">Starting job…</p>
      </div>
      <div class="media-meta">
        <span id="current-time">00:00:00</span>
        <span id="duration">--:--:--</span>
      </div>
      <div class="version-toggle" id="version-toggle">
        <button type="button" class="active" data-role="original">Full Quality</button>
        <button type="button" data-role="proxy">Lightweight</button>
      </div>
      <div class="status" id="status-line">No workspace selected. Choose a project first.</div>
    </section>
    <section class="panel transcript-panel">
      <div class="transcript-header">
        <h2>Transcript</h2>
        <span id="transcript-status" class="status-badge">Idle</span>
      </div>
      <div id="transcript" class="transcript-scroll">
        <p>Open a project with a transcript to preview it here.</p>
      </div>
    </section>
    <aside class="panel toolbox">
      <div class="toolbox-header">
        <h2 style="margin:0;font-size:0.9rem;text-transform:uppercase;letter-spacing:0.12em;color:var(--muted);">
          Toolbox
        </h2>
        <button id="refresh-scripts" class="toolbox-refresh" type="button">↺</button>
      </div>
      <div id="tool-list" class="tool-list"></div>
      <div id="job-list" class="job-list"></div>
    </aside>
  </main>

  <div id="file-manager-modal" class="file-modal hidden" role="dialog" aria-modal="true" aria-labelledby="file-manager-title">
    <div class="file-modal-dialog">
      <div class="file-modal-header">
        <div>
          <h2 id="file-manager-title">Workspace Files</h2>
          <p id="file-manager-path" class="file-modal-path"></p>
        </div>
        <button type="button" id="file-manager-close" class="icon-button small" aria-label="Close file manager">&times;</button>
      </div>
      <div class="file-modal-body">
        <div class="file-toolbar">
          <button type="button" id="file-download-selected" disabled>Download Selected</button>
          <button type="button" id="file-delete-selected" disabled>Delete Selected</button>
          <button type="button" id="file-download-all">Download Project (.zip)</button>
          <label for="file-upload-input">
            <svg viewBox="0 0 24 24" aria-hidden="true" style="width:16px;height:16px;fill:currentColor;"><path d="M5 20h14v-3h2v3a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-3h2v3Z" opacity="0.35"/><path d="M12 3a1 1 0 0 1 1 1v9.586l2.293-2.293a1 1 0 0 1 1.414 1.414l-4 4a1 1 0 0 1-1.414 0l-4-4a1 1 0 0 1 1.414-1.414L11 13.586V4a1 1 0 0 1 1-1Z"/></svg>
            Upload Files
          </label>
          <input id="file-upload-input" type="file" multiple />
          <span id="file-selection-count" class="file-selection-count">Select files to enable actions.</span>
        </div>
        <div id="file-breadcrumbs" class="file-breadcrumbs"></div>
        <div class="file-list">
          <div class="file-header">
            <span></span>
            <span>Name</span>
            <span>Size</span>
            <span>Modified</span>
            <span>Actions</span>
          </div>
          <div id="file-manager-rows" class="file-rows"></div>
        </div>
        <p id="file-manager-status" class="file-status"></p>
      </div>
    </div>
  </div>

  <div id="cover-preview-modal" class="cover-modal hidden" role="dialog" aria-modal="true" aria-labelledby="cover-preview-title">
    <div class="cover-modal-dialog">
      <div class="cover-modal-header">
        <h2 id="cover-preview-title">Covers</h2>
        <button type="button" id="cover-preview-close" class="icon-button small" aria-label="Close cover preview">&times;</button>
      </div>
      <div id="cover-preview-body" class="cover-modal-body"></div>
    </div>
  </div>

  <script>
    function redirectToLogin() {
      const current = window.location.pathname + window.location.search;
      const next = encodeURIComponent(current);
      window.location.replace(`/login.html?next=${next}`);
    }

    const originalFetch = window.fetch;
    window.fetch = async (...args) => {
      const response = await originalFetch(...args);
      if (response.status === 401) {
        redirectToLogin();
        throw new Error('unauthorized');
      }
      return response;
    };

    async function handleLogout(event) {
      if (event) {
        event.preventDefault();
      }
      try {
        await fetch('/api/logout', { method: 'POST' });
      } catch (error) {
        console.error('Logout failed', error);
      } finally {
        window.location.replace('/login.html');
      }
    }

    const statusLine = document.getElementById('status-line');
    const media = document.getElementById('media');
    const mediaSource = document.getElementById('media-source');
    const conversionLoader = document.getElementById('conversion-loader');
    const loaderFill = document.getElementById('loader-progress');
    const loaderText = document.getElementById('loader-text');
    const currentTimeEl = document.getElementById('current-time');
    const durationEl = document.getElementById('duration');
    const versionToggle = document.getElementById('version-toggle');
    const originalButton = versionToggle ? versionToggle.querySelector('[data-role="original"]') : null;
    const proxyButton = versionToggle ? versionToggle.querySelector('[data-role="proxy"]') : null;
    const toolList = document.getElementById('tool-list');
    const jobList = document.getElementById('job-list');
    const refreshScriptsBtn = document.getElementById('refresh-scripts');
    const pageTitle = document.getElementById('page-title');
    const titleForm = document.getElementById('title-form');
    const titleInput = document.getElementById('title-input');
    const titleSave = document.getElementById('title-save');
    const titleStatus = document.getElementById('title-status');
    const participantForm = document.getElementById('participant-form');
    const interviewerInput = document.getElementById('interviewer-input');
    const guestInput = document.getElementById('guest-input');
    const participantSave = document.getElementById('participant-save');
    const participantStatus = document.getElementById('participant-status');
    const transcriptEl = document.getElementById('transcript');
    const transcriptStatus = document.getElementById('transcript-status');
    const participantInfo = document.getElementById('participant-info');
    const interviewerLabelEl = document.getElementById('interviewer-label');
    const guestLabelEl = document.getElementById('guest-label');
    const logoutLink = document.getElementById('logout-link');
    const fileManagerButton = document.getElementById('file-manager-button');
    const fileManagerModal = document.getElementById('file-manager-modal');
    const fileManagerClose = document.getElementById('file-manager-close');
    const fileManagerRows = document.getElementById('file-manager-rows');
    const fileManagerStatus = document.getElementById('file-manager-status');
    const fileSelectionCount = document.getElementById('file-selection-count');
    const fileDownloadSelectedBtn = document.getElementById('file-download-selected');
    const fileDeleteSelectedBtn = document.getElementById('file-delete-selected');
    const fileDownloadAllBtn = document.getElementById('file-download-all');
    const fileBreadcrumbs = document.getElementById('file-breadcrumbs');
    const fileManagerPath = document.getElementById('file-manager-path');
    const coverPreviewModal = document.getElementById('cover-preview-modal');
    const coverPreviewClose = document.getElementById('cover-preview-close');
    const coverPreviewBody = document.getElementById('cover-preview-body');
    const fileUploadInput = document.getElementById('file-upload-input');

    let workspaceInfo = null;
    let workspaceProjectName = null;
    let workspaceFiles = { notes: null, srt: null, video: null, proxy: null, audio: null, transcript_json: null, chapters: null };
    let workspaceSources = { original: null, proxy: null };
    let currentSourceRole = 'original';
    const scriptButtons = new Map();
    const scriptStateCache = { key: null, data: {} };
    let transcriptSource = { kind: null, name: null, url: null };
    let wordSpans = [];
    let activeWordIndex = -1;
    let lastNotesContent = null;
    let guestName = '';
    let interviewerName = '';
    const fileManagerState = {
      currentDir: '.',
      entries: [],
      selected: new Set(),
      breadcrumbs: [],
    };
    let speakerMap = new Map();
    const SEEK_EPSILON = 0.2;
    const MERGE_GAP_SECONDS = 1.5;

    if (logoutLink) {
      logoutLink.addEventListener('click', handleLogout);
    }

    if (fileDownloadAllBtn) {
      fileDownloadAllBtn.disabled = true;
    }

    if (fileManagerButton) {
      fileManagerButton.addEventListener('click', () => openFileManager('.'));
    }

    if (fileManagerClose) {
      fileManagerClose.addEventListener('click', closeFileManager);
    }

    if (fileManagerModal) {
      fileManagerModal.addEventListener('click', (event) => {
        if (event.target === fileManagerModal) {
          closeFileManager();
        }
      });
    }

    if (coverPreviewModal) {
      coverPreviewModal.addEventListener('click', (event) => {
        if (event.target === coverPreviewModal) {
          closeCoverPreview();
        }
      });
    }

    if (coverPreviewClose) {
      coverPreviewClose.addEventListener('click', closeCoverPreview);
    }

    if (fileDeleteSelectedBtn) {
      fileDeleteSelectedBtn.addEventListener('click', () => {
        deleteFiles(Array.from(fileManagerState.selected));
      });
    }

    if (fileDownloadSelectedBtn) {
      fileDownloadSelectedBtn.addEventListener('click', () => {
        downloadSelected(Array.from(fileManagerState.selected));
      });
    }

    if (fileDownloadAllBtn) {
      fileDownloadAllBtn.addEventListener('click', downloadProjectArchive);
    }

    async function uploadFilesToWorkspace(files) {
      if (!files || !files.length) return;
      if (!workspaceInfo || !workspaceInfo.path) {
        alert('Select a project before uploading files.');
        return;
      }
      try {
        const summary = await fetch('/api/workspace').then((resp) => resp.json());
        const projectName = summary && summary.project_name ? summary.project_name : null;
        const workspacePath = summary && summary.path ? summary.path : null;
        if (projectName) {
          await uploadViaProjectsEndpoint(projectName, files);
          await loadWorkspace({ refresh: true });
          await refreshFileManager('.');
          return;
        }
        if (workspacePath) {
          await uploadViaWorkspaceEndpoint(workspacePath, files);
          await loadWorkspace({ refresh: true });
          await refreshFileManager('.');
          return;
        }
        alert('Workspace path unavailable; cannot determine upload target.');
      } catch (error) {
        console.error(error);
        alert('Upload failed: ' + error.message);
      }
    }

    function setFileUploadState(pending = false, message = 'Uploading…') {
      if (!fileManagerStatus) return;
      if (pending) {
        fileManagerStatus.textContent = message;
      } else {
        fileManagerStatus.textContent = '';
      }
    }

    function uploadViaProjectsEndpoint(projectName, files) {
      return new Promise((resolve, reject) => {
        const formData = new FormData();
        Array.from(files).forEach((file) => formData.append('files', file));
        setFileUploadState(true, 'Uploading…');
        const xhr = new XMLHttpRequest();
        xhr.open('POST', `/api/projects/upload?project=${encodeURIComponent(projectName)}`);
        xhr.upload.onprogress = (event) => {
          if (!event.lengthComputable) return;
          const pct = Math.max(0, Math.min(100, Math.round((event.loaded / event.total) * 100)));
          setFileUploadState(true, `Uploading… ${pct}%`);
        };
        xhr.onerror = () => {
          setFileUploadState(false);
          reject(new Error('Network error during upload.'));
        };
        xhr.onload = () => {
          setFileUploadState(false);
          if (xhr.status >= 200 && xhr.status < 300) {
            resolve(JSON.parse(xhr.responseText || '{}'));
          } else {
            reject(new Error(xhr.responseText || xhr.statusText));
          }
        };
        xhr.send(formData);
      });
    }

    function uploadViaWorkspaceEndpoint(workspacePath, files) {
      return new Promise((resolve, reject) => {
        const formData = new FormData();
        Array.from(files).forEach((file) => formData.append('files', file));
        setFileUploadState(true, 'Uploading…');
        const xhr = new XMLHttpRequest();
        xhr.open('POST', '/api/workspace/upload');
        xhr.setRequestHeader('X-Workspace-Path', workspacePath);
        xhr.upload.onprogress = (event) => {
          if (!event.lengthComputable) return;
          const pct = Math.max(0, Math.min(100, Math.round((event.loaded / event.total) * 100)));
          setFileUploadState(true, `Uploading… ${pct}%`);
        };
        xhr.onerror = () => {
          setFileUploadState(false);
          reject(new Error('Network error during upload.'));
        };
        xhr.onload = () => {
          setFileUploadState(false);
          if (xhr.status >= 200 && xhr.status < 300) {
            resolve(JSON.parse(xhr.responseText || '{}'));
          } else {
            reject(new Error(xhr.responseText || xhr.statusText));
          }
        };
        xhr.send(formData);
      });
    }

    if (fileUploadInput) {
      fileUploadInput.addEventListener('change', async (event) => {
        const input = event.target;
        if (!input.files || input.files.length === 0) return;
        const files = Array.from(input.files);
        input.value = '';
        await uploadFilesToWorkspace(files);
      });
    }

    document.addEventListener('keydown', (event) => {
      if (event.key !== 'Escape') return;
      if (coverPreviewModal && !coverPreviewModal.classList.contains('hidden')) {
        closeCoverPreview();
        return;
      }
      if (fileManagerModal && !fileManagerModal.classList.contains('hidden')) {
        closeFileManager();
      }
    });

    if (participantForm) {
      participantForm.addEventListener('submit', async (event) => {
        event.preventDefault();
        if (!participantSave || !interviewerInput || !guestInput) return;
        const nextInterviewer = interviewerInput.value.trim();
        const nextGuest = guestInput.value.trim();
        if (!lastNotesContent) {
          await loadNotesTitle();
          if (!lastNotesContent) {
            setParticipantFormState({ disabled: true, interviewer: nextInterviewer, guest: nextGuest, status: 'Notes unavailable' });
            return;
          }
        }
        setParticipantFormState({ disabled: true, interviewer: nextInterviewer, guest: nextGuest, status: 'Saving…' });
        try {
          let updated = replaceSectionFirstLine(lastNotesContent, '## Interviewer', nextInterviewer);
          updated = replaceSectionFirstLine(updated, '## Guest', nextGuest);
          const response = await fetch('/api/notes', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ content: updated }),
          });
          if (!response.ok) {
            throw new Error(await response.text());
          }
          await response.json();
          lastNotesContent = updated;
          interviewerName = nextInterviewer;
          guestName = nextGuest;
          updateParticipantDisplay();
          setParticipantFormState({ disabled: false, interviewer: nextInterviewer, guest: nextGuest, status: `Saved at ${new Date().toLocaleTimeString()}` });
        } catch (error) {
          console.error(error);
          alert('Unable to update participants: ' + error.message);
          setParticipantFormState({ disabled: false, interviewer: nextInterviewer, guest: nextGuest, status: 'Save failed' });
        }
      });
    }

    function updateBodyModalState() {
      const filesOpen = fileManagerModal && !fileManagerModal.classList.contains('hidden');
      const coversOpen = coverPreviewModal && !coverPreviewModal.classList.contains('hidden');
      if (filesOpen || coversOpen) {
        document.body.classList.add('modal-open');
      } else {
        document.body.classList.remove('modal-open');
      }
    }

    function updateParticipantDisplay() {
      if (interviewerLabelEl) {
        const nameEl = interviewerLabelEl.querySelector('.participant-name');
        if (nameEl) {
          nameEl.textContent = interviewerName || '—';
        } else {
          interviewerLabelEl.textContent = interviewerName ? `Interviewer: ${interviewerName}` : 'Interviewer: —';
        }
        interviewerLabelEl.classList.toggle('missing', !interviewerName);
      }
      if (guestLabelEl) {
        const nameEl = guestLabelEl.querySelector('.participant-name');
        if (nameEl) {
          nameEl.textContent = guestName || '—';
        } else {
          guestLabelEl.textContent = guestName ? `Guest: ${guestName}` : 'Guest: —';
        }
        guestLabelEl.classList.toggle('missing', !guestName);
      }
      if (participantInfo) {
        const hasNames = Boolean(guestName || interviewerName);
        participantInfo.classList.toggle('all-missing', !hasNames);
      }
      setParticipantFormState({
        disabled: participantSave ? participantSave.disabled : true,
        interviewer: interviewerName || '',
        guest: guestName || '',
        status: participantStatus ? participantStatus.textContent : undefined,
      });
    }

    function setParticipantFormState({ disabled = false, interviewer = null, guest = null, status } = {}) {
      const nextStatus = typeof status === 'string'
        ? status
        : (participantStatus ? participantStatus.textContent || 'Idle' : 'Idle');
      if (typeof interviewer === 'string' && interviewerInput) {
        interviewerInput.value = interviewer;
      }
      if (typeof guest === 'string' && guestInput) {
        guestInput.value = guest;
      }
      if (participantSave) {
        participantSave.disabled = disabled;
      }
      if (interviewerInput) {
        interviewerInput.disabled = disabled;
      }
      if (guestInput) {
        guestInput.disabled = disabled;
      }
      if (participantStatus) {
        participantStatus.textContent = nextStatus;
      }
    }

    async function setWorkspacePath(path) {
      const response = await fetch('/api/workspace', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ path }),
      });
      if (!response.ok) {
        const detail = await response.text();
        throw new Error(detail || response.statusText);
      }
      return response.json();
    }

    function workspaceUrl(name) {
      if (!name) return null;
      return "/workspace/" + name.split("/").map(encodeURIComponent).join("/");
    }

    function triggerDownload(url, filename) {
      if (!url) return;
      const anchor = document.createElement('a');
      anchor.href = url;
      if (filename) {
        anchor.download = filename;
      }
      document.body.appendChild(anchor);
      anchor.click();
      document.body.removeChild(anchor);
    }

    function humanFileSize(bytes) {
      if (bytes === null || bytes === undefined) return '—';
      if (bytes === 0) return '0 B';
      const units = ['B', 'KB', 'MB', 'GB', 'TB'];
      let value = bytes;
      let unitIndex = 0;
      while (value >= 1024 && unitIndex < units.length - 1) {
        value /= 1024;
        unitIndex += 1;
      }
      const decimals = unitIndex === 0 || value >= 10 ? 0 : 1;
      return `${value.toFixed(decimals)} ${units[unitIndex]}`;
    }

    function formatModified(timestamp) {
      if (!timestamp) return '—';
      try {
        return new Date(timestamp * 1000).toLocaleString();
      } catch (error) {
        return '—';
      }
    }

    function updateDownloadAllState() {
      if (!fileDownloadAllBtn) return;
      fileDownloadAllBtn.disabled = !workspaceProjectName;
    }

    function resetFileManagerSelection() {
      fileManagerState.selected.clear();
      if (fileManagerRows) {
        fileManagerRows.querySelectorAll('.file-row').forEach((row) => row.classList.remove('selected'));
        fileManagerRows.querySelectorAll('input[type="checkbox"]').forEach((checkbox) => {
          checkbox.checked = false;
        });
      }
      updateFileManagerActions();
    }

    function updateFileManagerActions() {
      if (!fileSelectionCount) return;
      const count = fileManagerState.selected.size;
      fileSelectionCount.textContent = count
        ? `${count} item${count === 1 ? '' : 's'} selected`
        : 'Select files to enable actions.';
      if (fileDownloadSelectedBtn) {
        fileDownloadSelectedBtn.disabled = count === 0;
      }
      if (fileDeleteSelectedBtn) {
        fileDeleteSelectedBtn.disabled = count === 0;
      }
      updateDownloadAllState();
    }

    function updateFileManagerBreadcrumbs() {
      if (!fileBreadcrumbs) return;
      fileBreadcrumbs.textContent = '';
      const crumbs = (fileManagerState.breadcrumbs && fileManagerState.breadcrumbs.length)
        ? fileManagerState.breadcrumbs
        : [{ label: 'Workspace', path: '.' }];
      crumbs.forEach((crumb, index) => {
        if (index > 0) {
          const divider = document.createElement('span');
          divider.textContent = '/';
          divider.style.opacity = 0.6;
          fileBreadcrumbs.appendChild(divider);
        }
        const button = document.createElement('button');
        button.type = 'button';
        button.textContent = crumb.label || crumb.path || '.';
        button.addEventListener('click', () => {
          refreshFileManager(crumb.path || '.');
        });
        fileBreadcrumbs.appendChild(button);
      });
    }

    function updateFileManagerPathLabel() {
      if (!fileManagerPath) return;
      const dir = fileManagerState.currentDir;
      const suffix = dir === '.' ? 'Workspace' : `Workspace/${dir}`;
      fileManagerPath.textContent = suffix;
    }

    function handleRowSelection(path, checked, rowElement) {
      if (!path) return;
      if (checked) {
        fileManagerState.selected.add(path);
        if (rowElement) rowElement.classList.add('selected');
      } else {
        fileManagerState.selected.delete(path);
        if (rowElement) rowElement.classList.remove('selected');
      }
      updateFileManagerActions();
    }

    function buildFileRow(entry) {
      const row = document.createElement('div');
      row.className = 'file-row';
      row.dataset.path = entry.path;
      if (entry.is_dir) {
        row.classList.add('directory');
      }

      const checkboxWrapper = document.createElement('div');
      const checkbox = document.createElement('input');
      checkbox.type = 'checkbox';
      checkbox.addEventListener('change', (event) => {
        handleRowSelection(entry.path, event.target.checked, row);
      });
      checkboxWrapper.appendChild(checkbox);
      row.appendChild(checkboxWrapper);

      const nameButton = document.createElement('button');
      nameButton.type = 'button';
      nameButton.className = 'file-name';
      const iconSvg = entry.is_dir
        ? '<svg viewBox="0 0 24 24"><path d="M4 6a2 2 0 0 1 2-2h4.172a2 2 0 0 1 1.414.586L12.828 6H18a2 2 0 0 1 2 2v8a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2Z"/></svg>'
        : '<svg viewBox="0 0 24 24"><path d="M6 2a2 2 0 0 0-2 2v16l6-3 6 3V4a2 2 0 0 0-2-2H6z"/></svg>';
      nameButton.innerHTML = `${iconSvg}<span>${entry.name}</span>`;
      if (entry.is_dir) {
        nameButton.addEventListener('click', () => {
          refreshFileManager(entry.path);
        });
      } else {
        nameButton.addEventListener('click', () => {
          const url = workspaceUrl(entry.path);
          triggerDownload(url, entry.name);
        });
      }
      row.appendChild(nameButton);

      const sizeSpan = document.createElement('span');
      sizeSpan.textContent = entry.is_dir ? '—' : humanFileSize(entry.size);
      row.appendChild(sizeSpan);

      const modifiedSpan = document.createElement('span');
      modifiedSpan.textContent = formatModified(entry.modified);
      row.appendChild(modifiedSpan);

      const actions = document.createElement('div');
      actions.className = 'file-actions';
      const downloadBtn = document.createElement('button');
      downloadBtn.type = 'button';
      downloadBtn.textContent = 'Download';
      downloadBtn.addEventListener('click', () => {
        downloadSelected([entry.path]);
      });
      const deleteBtn = document.createElement('button');
      deleteBtn.type = 'button';
      deleteBtn.textContent = 'Delete';
      deleteBtn.addEventListener('click', () => {
        deleteFiles([entry.path]);
      });
      actions.appendChild(downloadBtn);
      actions.appendChild(deleteBtn);
      row.appendChild(actions);

      return row;
    }

    function updateFileManagerRows() {
      if (!fileManagerRows) return;
      fileManagerRows.textContent = '';
      if (!fileManagerState.entries.length) {
        const empty = document.createElement('div');
        empty.className = 'file-empty-message';
        empty.textContent = 'No files in this directory yet.';
        fileManagerRows.appendChild(empty);
        return;
      }
      fileManagerState.entries.forEach((entry) => {
        const row = buildFileRow(entry);
        fileManagerRows.appendChild(row);
      });
    }

    function renderFileManager(data) {
      fileManagerState.currentDir = data.directory || '.';
      fileManagerState.entries = data.entries || [];
      fileManagerState.breadcrumbs = data.breadcrumbs || [];
      fileManagerState.selected.clear();
      updateFileManagerBreadcrumbs();
      updateFileManagerPathLabel();
      updateFileManagerRows();
      updateFileManagerActions();
      if (fileManagerStatus) {
        fileManagerStatus.textContent = '';
      }
      if (typeof data.project_name === 'string') {
        workspaceProjectName = data.project_name;
        updateDownloadAllState();
      }
    }

    async function refreshFileManager(dir = fileManagerState.currentDir) {
      if (!fileManagerModal || fileManagerModal.classList.contains('hidden')) return;
      try {
        if (fileManagerStatus) {
          fileManagerStatus.textContent = 'Loading…';
        }
        const params = new URLSearchParams();
        if (dir && dir !== '.') {
          params.set('dir', dir);
        }
        const response = await fetch(`/api/workspace/files?${params.toString()}`);
        const data = await response.json();
        if (!response.ok) {
          throw new Error(data.error || response.statusText);
        }
        renderFileManager(data);
      } catch (error) {
        console.error(error);
        if (fileManagerStatus) {
          fileManagerStatus.textContent = `Unable to list files: ${error.message}`;
        }
      }
    }

    function openFileManager(dir = '.') {
      if (!fileManagerModal) return;
      if (!workspaceInfo || !workspaceInfo.path) {
        alert('Select a project before managing files.');
        return;
      }
      fileManagerModal.classList.remove('hidden');
      fileManagerStatus.textContent = '';
      updateDownloadAllState();
      updateBodyModalState();
      refreshFileManager(dir);
    }

    function closeFileManager() {
      if (!fileManagerModal) return;
      fileManagerModal.classList.add('hidden');
      resetFileManagerSelection();
      if (fileManagerStatus) {
        fileManagerStatus.textContent = '';
      }
      updateBodyModalState();
    }

    async function deleteFiles(paths) {
      if (!paths || !paths.length) return;
      const confirmDelete = window.confirm(
        paths.length === 1
          ? `Delete “${paths[0]}”? This action cannot be undone.`
          : `Delete ${paths.length} items? This action cannot be undone.`
      );
      if (!confirmDelete) return;

      try {
        const response = await fetch('/api/workspace/delete-files', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ paths }),
        });
        const data = await response.json();
        if (!response.ok) {
          throw new Error(data.error || response.statusText);
        }
        if (fileManagerStatus) {
          fileManagerStatus.textContent = `Deleted ${data.paths.length} item${data.paths.length === 1 ? '' : 's'}.`;
        }
        resetFileManagerSelection();
        await loadWorkspace({ refresh: true });
        await refreshFileManager(fileManagerState.currentDir);
      } catch (error) {
        console.error(error);
        if (fileManagerStatus) {
          fileManagerStatus.textContent = `Delete failed: ${error.message}`;
        }
      }
    }

    async function downloadSelected(paths) {
      if (!paths || !paths.length) return;
      if (paths.length === 1) {
        const relative = paths[0];
        const selectedEntry = fileManagerState.entries.find((entry) => entry.path === relative);
        const url = workspaceUrl(relative);
        if (selectedEntry && selectedEntry.is_dir) {
          const ok = await downloadZip(paths);
          if (ok) {
            resetFileManagerSelection();
          }
          return;
        } else {
          triggerDownload(url, selectedEntry ? selectedEntry.name : undefined);
          resetFileManagerSelection();
          return;
        }
      }
      const ok = await downloadZip(paths);
      if (ok) {
        resetFileManagerSelection();
      }
    }

    async function downloadZip(paths) {
      try {
        if (fileManagerStatus) {
          fileManagerStatus.textContent = 'Preparing download…';
        }
        const response = await fetch('/api/workspace/download-zip', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ paths }),
        });
        if (!response.ok) {
          const errorPayload = await response.json().catch(() => ({}));
          throw new Error(errorPayload.error || response.statusText);
        }
        const blob = await response.blob();
        const url = URL.createObjectURL(blob);
        triggerDownload(url, 'workspace-files.zip');
        setTimeout(() => URL.revokeObjectURL(url), 1500);
        if (fileManagerStatus) {
          fileManagerStatus.textContent = '';
        }
        return true;
      } catch (error) {
        console.error(error);
        if (fileManagerStatus) {
          fileManagerStatus.textContent = `Download failed: ${error.message}`;
        }
        return false;
      }
    }

    function downloadProjectArchive() {
      if (!workspaceProjectName) {
        if (fileManagerStatus) {
          fileManagerStatus.textContent = 'Project zip is only available for workspaces inside the Projects folder.';
        }
        return;
      }
      if (fileManagerStatus) {
        fileManagerStatus.textContent = 'Preparing project archive…';
      }
      const url = `/api/projects/download?project=${encodeURIComponent(workspaceProjectName)}`;
      triggerDownload(url, `${workspaceProjectName}.zip`);
      setTimeout(() => {
        if (fileManagerStatus && fileManagerModal && !fileManagerModal.classList.contains('hidden')) {
          fileManagerStatus.textContent = '';
        }
      }, 1200);
    }

    async function applyWorkspaceFromQuery() {
      const params = new URLSearchParams(window.location.search);
      const workspace = params.get('workspace');
      if (!workspace) return;
      try {
        await setWorkspacePath(workspace);
        try {
          window.localStorage.setItem('podfreeWorkspacePath', workspace);
        } catch (error) {
          console.warn('Unable to persist workspace path from query:', error);
        }
      } catch (error) {
        console.error('Failed to set workspace from URL parameter:', error);
        statusLine.textContent = `Workspace unavailable: ${error.message}`;
      } finally {
        params.delete('workspace');
        const nextSearch = params.toString();
        const nextUrl = `${window.location.pathname}${nextSearch ? `?${nextSearch}` : ''}${window.location.hash || ''}`;
        window.history.replaceState({}, '', nextUrl);
      }
    }

    async function applyPendingWorkspace() {
      let pendingPath = null;
      try {
        pendingPath = window.localStorage.getItem('podfreeWorkspacePath');
      } catch (error) {
        console.warn('Unable to read stored workspace path:', error);
      }
      if (!pendingPath) return;
      try {
        await setWorkspacePath(pendingPath);
      } catch (error) {
        console.error('Failed to restore workspace from storage:', error);
        statusLine.textContent = `Workspace unavailable: ${error.message}`;
      }
      try {
        window.localStorage.removeItem('podfreeWorkspacePath');
      } catch (error) {
        console.warn('Unable to clear stored workspace path:', error);
      }
    }

    function updateLinks(path) {
      const params = new URLSearchParams();
      if (path) params.set('workspace', path);
      // No auxiliary links in Editor header, but keep placeholder for future use
      const _suffix = params.toString() ? `?${params.toString()}` : '';
    }

    function workspaceLabel(summary) {
      if (!summary || !summary.path) return null;
      const parts = summary.path.split(/[/\\]+/).filter(Boolean);
      return parts.length ? parts[parts.length - 1] : null;
    }

    function updatePageHeader(summary) {
      const label = workspaceLabel(summary);
      if (pageTitle) {
        pageTitle.textContent = label ? `Edit ${label}` : 'Edit Project';
      }
      if (!label) {
        setTitleFormState({ disabled: true, value: '', status: 'Open a project from Projects →' });
      }
    }

    function setTitleFormState({ disabled = false, value = '', status = 'Idle' } = {}) {
      if (titleInput) {
        titleInput.disabled = disabled;
        if (typeof value === 'string') {
          titleInput.value = value;
        }
      }
      if (titleSave) {
        titleSave.disabled = disabled;
      }
      if (titleStatus) {
        titleStatus.textContent = status;
      }
    }

    function extractTitleSection(content) {
      if (typeof content !== 'string') return '';
      const lines = content.split(/\r?\n/);
      let idx = lines.findIndex((line) => line.trim().toLowerCase() === '## title');
      if (idx === -1) return '';
      idx += 1;
      while (idx < lines.length && !lines[idx].trim()) idx += 1;
      return idx < lines.length ? lines[idx].trim() : '';
    }

    function replaceTitleSection(content, newTitle) {
      const lines = content.split(/\r?\n/);
      let idx = lines.findIndex((line) => line.trim().toLowerCase() === '## title');
      if (idx === -1) {
        lines.push('', '## Title', newTitle, '');
        return lines.join('\n');
      }
      idx += 1;
      while (idx < lines.length && !lines[idx].trim()) {
        idx += 1;
      }
      if (idx >= lines.length) {
        lines.push(newTitle, '');
      } else {
        lines[idx] = newTitle;
      }
      return lines.join('\n');
    }

    function replaceSectionFirstLine(content, heading, newLine) {
      const lines = content.split(/\r?\n/);
      const target = String(heading || '').trim().toLowerCase();
      let idx = lines.findIndex((line) => line.trim().toLowerCase() === target);
      if (idx === -1) {
        lines.push('', heading, newLine, '');
        return lines.join('\n');
      }
      idx += 1;
      while (idx < lines.length && !lines[idx].trim()) {
        idx += 1;
      }
      if (idx >= lines.length || lines[idx].startsWith('## ')) {
        lines.splice(idx, 0, newLine, '');
      } else {
        lines[idx] = newLine;
      }
      return lines.join('\n');
    }

    function extractSectionFirstLine(content, headings) {
      if (!content) return '';
      const lines = content.split(/\r?\n/);
      const normalized = lines.map((line) => line.trim().toLowerCase());
      let idx = -1;
      for (const heading of headings) {
        const target = `## ${heading}`.toLowerCase();
        idx = normalized.indexOf(target);
        if (idx !== -1) break;
      }
      if (idx === -1) return '';
      idx += 1;
      while (idx < lines.length && !lines[idx].trim()) idx += 1;
      return idx < lines.length ? lines[idx].trim() : '';
    }

    function normalizeSpeakerId(raw) {
      if (raw === undefined || raw === null) return { raw: null, numeric: null };
      if (typeof raw === 'number' && Number.isFinite(raw)) {
        return { raw, numeric: raw };
      }
      const str = String(raw);
      const match = str.match(/(-?\d+(?:\.\d+)?)/);
      const numeric = match ? Number(match[1]) : null;
      return { raw, numeric: Number.isFinite(numeric) ? numeric : null };
    }

    function buildSpeakerMapping(segments) {
      const encountered = [];
      segments.forEach((seg) => {
        const id = seg.speaker;
        if (id === undefined || id === null) return;
        if (!encountered.some((entry) => entry.raw === id)) {
          encountered.push({ raw: id, ...normalizeSpeakerId(id), order: encountered.length });
        }
      });
      const map = new Map();
      const assigned = new Set();
      const assign = (entry, role, label) => {
        const payload = { role, label };
        const { raw, numeric } = entry;
        map.set(raw, payload);
        const rawStr = typeof raw === 'string' ? raw : null;
        if (rawStr) {
          map.set(rawStr, payload);
        }
        if (Number.isFinite(numeric)) {
          map.set(numeric, payload);
          map.set(String(numeric), payload);
        }
        if (role) assigned.add(role);
      };
      const interviewerLabel = interviewerName || 'Interviewer';
      const guestLabel = guestName || 'Guest';

      encountered.forEach((entry, index) => {
        if (!assigned.has('interviewer')) {
          assign(entry, 'interviewer', interviewerLabel);
          return;
        }
        if (!assigned.has('guest') && index > 0) {
          assign(entry, 'guest', guestLabel);
          return;
        }
        const numeric = Number.isFinite(entry.numeric) ? entry.numeric : null;
        const rawLabel = typeof entry.raw === 'string' ? entry.raw.trim() : '';
        const label = rawLabel || `Speaker ${Number.isFinite(numeric) ? numeric : index + 1}`;
        assign(entry, 'other', label);
      });
      speakerMap = map;
    }

    function resolveSpeakerInfo(speaker) {
      if (speaker === undefined || speaker === null) {
        return { role: 'narration', label: 'Narration' };
      }
      if (speakerMap.has(speaker)) {
        return speakerMap.get(speaker);
      }
      return { role: 'other', label: `Speaker ${speaker}` };
    }

    function speakerClassForRole(role) {
      switch (role) {
        case 'interviewer':
          return 'speaker-interviewer';
        case 'guest':
          return 'speaker-guest';
        case 'narration':
          return 'speaker-narration';
        default:
          return 'speaker-other';
      }
    }

    function resetTranscript(message, status = 'Idle') {
      transcriptSource = { kind: null, name: null, url: null };
      wordSpans = [];
      activeWordIndex = -1;
      speakerMap = new Map();
      if (transcriptStatus) {
        transcriptStatus.textContent = status;
      }
      if (transcriptEl) {
        transcriptEl.textContent = '';
        const paragraph = document.createElement('p');
        paragraph.textContent = message;
        transcriptEl.appendChild(paragraph);
      }
    }

    function parseSRT(data) {
      const entries = [];
      const blocks = data.split(/\r?\n\r?\n+/);
      for (const block of blocks) {
        const lines = block.trim().split(/\r?\n/).filter(Boolean);
        if (lines.length < 2) continue;
        let idx = 0;
        if (/^\d+$/.test(lines[0].trim())) {
          idx = 1;
        }
        const times = lines[idx];
        const match = times.match(/(.+?)\s+-->\s+(.+?)/);
        if (!match) continue;
        const text = lines.slice(idx + 1).join(' ').replace(/\s+/g, ' ').trim();
        if (!text) continue;
        const label = match[1].split(',')[0];
        const startSeconds = timecodeToSeconds(label);
        const endSeconds = parseTimecode(match[2]);
        entries.push({ time: label, seconds: startSeconds, endSeconds, text, speaker: null });
      }
      return entries;
    }

    function renderTranscript(segments) {
      if (!transcriptEl || !transcriptStatus) return;
      if (!segments.length) {
        transcriptStatus.textContent = 'Empty';
        transcriptEl.innerHTML = '<p>Transcript file loaded but no caption entries were detected.</p>';
        return;
      }
      transcriptStatus.textContent = 'Ready';
      wordSpans = [];
      activeWordIndex = -1;
      const sorted = [...segments].sort((a, b) => {
        const aSec = Number(a.seconds ?? Number.MAX_VALUE);
        const bSec = Number(b.seconds ?? Number.MAX_VALUE);
        return aSec - bSec;
      });
      buildSpeakerMapping(sorted);
      const described = sorted.map((segment) => ({
        ...segment,
        info: resolveSpeakerInfo(segment.speaker),
      }));
      const mergedSegments = mergeSegmentsBySpeaker(described);
      const fragment = document.createDocumentFragment();
      mergedSegments.forEach((segment) => {
        const info = segment.info || resolveSpeakerInfo(segment.speaker);
        const entry = document.createElement('div');
        entry.className = `transcript-entry ${speakerClassForRole(info?.role)}`;

        const meta = document.createElement('div');
        meta.className = 'transcript-meta';
        const labelParts = [];
        if (info && info.label) labelParts.push(info.label);
        if (Number.isFinite(segment.seconds)) {
          labelParts.push(formatTime(Number(segment.seconds)));
        } else if (segment.time) {
          labelParts.push(segment.time);
        }
        if (!labelParts.length) {
          labelParts.push('Speaker');
        }
        meta.textContent = labelParts.join(' · ');
        entry.appendChild(meta);

        const paragraph = document.createElement('p');

        const tokens = segmentText(segment.text || '');
        let words = tokens.filter((token) => token.isWord);
        const startSeconds = Number(segment.seconds) || 0;
        let endSeconds = Number(segment.endSeconds);
        if (!Number.isFinite(endSeconds) || endSeconds <= startSeconds) {
          const approx = Math.max(words.length * 0.32, 0.6);
          endSeconds = startSeconds + approx;
        }
        if (!words.length && segment.text && segment.text.trim()) {
          tokens.length = 0;
          tokens.push({ value: segment.text.trim(), isWord: true });
          words = tokens;
        }

        const totalWords = Math.max(words.length, 1);
        const step = Math.max((endSeconds - startSeconds) / totalWords, 0.12);
        let wordIndex = 0;

        tokens.forEach((token) => {
          if (!token.isWord) {
            paragraph.append(token.value);
            return;
          }
          const span = document.createElement('span');
          span.className = 'word';
          span.textContent = token.value;
          const wordStart = startSeconds + step * wordIndex;
          const isLastWord = wordIndex === totalWords - 1;
          let wordEnd = isLastWord ? endSeconds : Math.min(startSeconds + step * (wordIndex + 1), endSeconds);
          if (!Number.isFinite(wordEnd) || wordEnd <= wordStart) {
            wordEnd = wordStart + 0.12;
          }
          const wordEntry = { element: span, start: wordStart, end: wordEnd };
          const index = wordSpans.push(wordEntry) - 1;
          span.dataset.start = String(wordStart);
          span.title = `Seek to ${formatTime(wordStart)}`;
          span.addEventListener('click', () => {
            media.currentTime = Math.max(0, wordStart - SEEK_EPSILON);
            highlightWordByIndex(index);
            media.play().catch(() => {});
          });
          paragraph.appendChild(span);
          wordIndex += 1;
        });

        entry.appendChild(paragraph);
        fragment.appendChild(entry);
      });
      transcriptEl.textContent = '';
      transcriptEl.appendChild(fragment);
    }

    function highlightWordByIndex(index) {
      if (index === activeWordIndex || index < 0 || index >= wordSpans.length) {
        return;
      }
      if (activeWordIndex >= 0) {
        wordSpans[activeWordIndex].element.classList.remove('active');
      }
      const entry = wordSpans[index];
      entry.element.classList.add('active');
      activeWordIndex = index;
      if (!transcriptEl) return;
      const containerRect = transcriptEl.getBoundingClientRect();
      const spanRect = entry.element.getBoundingClientRect();
      const offset = 48;
      if (spanRect.top < containerRect.top + offset || spanRect.bottom > containerRect.bottom - offset) {
        entry.element.scrollIntoView({ behavior: 'smooth', block: 'center' });
      }
    }

    function updateActiveWord(time) {
      if (!wordSpans.length) return;
      let index = activeWordIndex;
      if (index >= 0) {
        const current = wordSpans[index];
        if (time >= current.start && time < current.end) {
          return;
        }
        if (time >= current.end) {
          while (index + 1 < wordSpans.length && time >= wordSpans[index + 1].start) {
            index += 1;
            if (time < wordSpans[index].end) break;
          }
          if (time >= wordSpans[index].start && time < wordSpans[index].end) {
            highlightWordByIndex(index);
            return;
          }
        }
        if (time < current.start) {
          while (index > 0 && time < wordSpans[index].start) {
            index -= 1;
            if (time >= wordSpans[index].start) break;
          }
          if (time >= wordSpans[index].start && time < wordSpans[index].end) {
            highlightWordByIndex(index);
            return;
          }
        }
      }
      let low = 0;
      let high = wordSpans.length - 1;
      let found = -1;
      while (low <= high) {
        const mid = Math.floor((low + high) / 2);
        const entry = wordSpans[mid];
        if (time < entry.start) {
          high = mid - 1;
        } else if (time >= entry.end) {
          low = mid + 1;
        } else {
          found = mid;
          break;
        }
      }
      if (found !== -1) {
        highlightWordByIndex(found);
      }
    }

    function parseTranscriptJSON(data) {
      const entries = [];
      if (!data || typeof data !== 'object') {
        return entries;
      }
      const contributions = Array.isArray(data.contributions) ? data.contributions : [];
      if (contributions.length) {
        contributions.forEach((item) => {
          const seconds = item.start_time_seconds ?? item.start_time ?? 0;
          let endSeconds = item.end_time_seconds ?? item.end_time;
          const text = (item.text || '').trim();
          if (!text) return;
          if (!Number.isFinite(endSeconds) || Number(endSeconds) <= Number(seconds)) {
            const approx = Math.max(text.split(/\s+/).length * 0.32, 0.6);
            endSeconds = Number(seconds) + approx;
          }
          entries.push({
            time: formatSecondsLabel(seconds),
            seconds: Number(seconds) || 0,
            endSeconds: Number(endSeconds) || (Number(seconds) || 0),
            text,
            speaker: item.speaker ?? item.speaker_id ?? null,
          });
        });
        return entries;
      }

      const utterances = data?.results?.utterances;
      if (Array.isArray(utterances) && utterances.length) {
        utterances.forEach((utt) => {
          const text = (utt.transcript || utt.text || '').trim();
          if (!text) return;
          const start = Number(utt.start ?? utt.start_time ?? 0) || 0;
          let end = Number(utt.end ?? utt.end_time);
          if (!Number.isFinite(end) || end <= start) {
            const approx = Math.max(text.split(/\s+/).length * 0.32, 0.6);
            end = start + approx;
          }
          entries.push({
            time: formatSecondsLabel(start),
            seconds: start,
            endSeconds: end,
            text,
            speaker: utt.speaker ?? utt.speaker_id ?? null,
          });
        });
        return entries;
      }

      const paragraphs = data?.results?.channels?.[0]?.alternatives?.[0]?.paragraphs?.paragraphs;
      if (Array.isArray(paragraphs) && paragraphs.length) {
        paragraphs.forEach((para) => {
          const start = para.start ?? 0;
          let end = para.end;
          const text = (para.text || '').trim();
          if (!text) return;
          if (!Number.isFinite(end) || Number(end) <= Number(start)) {
            const approx = Math.max(text.split(/\s+/).length * 0.32, 0.6);
            end = Number(start) + approx;
          }
          entries.push({
            time: formatSecondsLabel(start),
            seconds: Number(start) || 0,
            endSeconds: Number(end) || (Number(start) || 0),
            text,
            speaker: para.speaker ?? para.speaker_id ?? null,
          });
        });
        return entries;
      }

      const words = data?.results?.channels?.[0]?.alternatives?.[0]?.words;
      if (Array.isArray(words) && words.length) {
        const buffer = [];
        let currentStart = words[0]?.start ?? 0;
        let chunkSpeaker = words[0]?.speaker ?? words[0]?.speaker_id ?? null;
        words.forEach((word) => {
          if ((buffer.join(' ') + ' ' + (word.word || '')).length > 80) {
            const chunkEnd = word.start ?? word.end ?? (currentStart + Math.max(buffer.length * 0.32, 0.6));
            entries.push({
              time: formatSecondsLabel(currentStart),
              seconds: Number(currentStart) || 0,
              endSeconds: Number(chunkEnd) || Number(currentStart) || 0,
              text: buffer.join(' '),
              speaker: chunkSpeaker,
            });
            buffer.length = 0;
            currentStart = word.start ?? currentStart;
            chunkSpeaker = word.speaker ?? word.speaker_id ?? chunkSpeaker;
          }
          if (word.word) buffer.push(word.word);
        });
        if (buffer.length) {
          const approx = Math.max(buffer.length * 0.32, 0.6);
          entries.push({
            time: formatSecondsLabel(currentStart),
            seconds: Number(currentStart) || 0,
            endSeconds: Number(currentStart + approx) || 0,
            text: buffer.join(' '),
            speaker: chunkSpeaker,
          });
        }
      }
      return entries;
    }

    async function loadTranscript() {
      if (!transcriptSource || !transcriptSource.url) {
        resetTranscript('No transcript file detected for this project.', 'Missing');
        return;
      }
      if (transcriptStatus) transcriptStatus.textContent = 'Loading…';
      try {
        const response = await fetch(transcriptSource.url);
        if (!response.ok) {
          throw new Error(`HTTP ${response.status}`);
        }
        if (transcriptSource.kind === 'json') {
          const data = await response.json();
          const segments = parseTranscriptJSON(data);
          if (segments.length) {
            renderTranscript(segments);
            updateActiveWord(media.currentTime || 0);
          } else {
            resetTranscript('Transcript JSON loaded but no entries were found.', 'Empty');
            return;
          }
        } else {
          const text = await response.text();
          const segments = parseSRT(text);
          renderTranscript(segments);
          updateActiveWord(media.currentTime || 0);
        }
      } catch (error) {
        console.error(error);
        resetTranscript(`Unable to load transcript: ${error.message}`, 'Error');
      }
    }

    async function loadNotesTitle() {
      try {
        const response = await fetch('/api/notes');
        if (!response.ok) {
          throw new Error(await response.text());
        }
        const data = await response.json();
    lastNotesContent = data.content || '';
    const currentTitle = extractTitleSection(lastNotesContent) || '';
    guestName = extractSectionFirstLine(lastNotesContent, ['guest']) || '';
    interviewerName = extractSectionFirstLine(lastNotesContent, ['interviewer', 'interviwer']) || '';
    updateParticipantDisplay();
    setTitleFormState({ disabled: false, value: currentTitle, status: 'Idle' });
    setParticipantFormState({ disabled: false, interviewer: interviewerName || '', guest: guestName || '', status: 'Idle' });
  } catch (error) {
    console.error(error);
    lastNotesContent = null;
    guestName = '';
    interviewerName = '';
    updateParticipantDisplay();
    setTitleFormState({ disabled: true, value: '', status: 'Notes unavailable' });
    setParticipantFormState({ disabled: true, interviewer: '', guest: '', status: 'Notes unavailable' });
  }
}

    function describe(name) {
      return name || '—';
    }

    function formatTime(seconds) {
      if (!Number.isFinite(seconds) || seconds < 0) return '--:--:--';
      const hrs = Math.floor(seconds / 3600);
      const mins = Math.floor((seconds % 3600) / 60);
      const secs = Math.floor(seconds % 60);
      return [hrs, mins, secs].map((part) => String(part).padStart(2, '0')).join(':');
    }

    function formatSecondsLabel(seconds) {
      return formatTime(Math.max(0, Number(seconds) || 0));
    }

    function timecodeToSeconds(code) {
      if (typeof code !== 'string') return 0;
      const clean = code.replace(',', '.');
      const parts = clean.split(':').map(Number);
      if (parts.length !== 3 || parts.some((part) => Number.isNaN(part))) {
        return 0;
      }
      const [hrs, mins, secs] = parts;
      return hrs * 3600 + mins * 60 + secs;
    }

    function parseTimecode(value) {
      const match = value.trim().match(/(\d+):(\d+):(\d+)[,\.]?(\d+)?/);
      if (!match) return 0;
      const [, hh, mm, ss, ms = '0'] = match;
      return Number(hh) * 3600 + Number(mm) * 60 + Number(ss) + Number(ms) / 1000;
    }

    function segmentText(text) {
      if (window.Intl && Intl.Segmenter) {
        const segmenter = new Intl.Segmenter(undefined, { granularity: 'word' });
        return Array.from(segmenter.segment(text)).map(({ segment, isWordLike }) => ({
          value: segment,
          isWord: Boolean(isWordLike && segment.trim()),
        }));
      }
      return (text.match(/\S+|\s+/g) || []).map((segment) => ({
        value: segment,
        isWord: Boolean(segment.trim()),
      }));
    }

    function normalizeSegmentTiming(segment) {
      const info = segment.info || resolveSpeakerInfo(segment.speaker);
      const safeText = typeof segment.text === 'string' ? segment.text.trim() : '';
      const startValue = Number(segment.seconds);
      const startSeconds = Number.isFinite(startValue) ? startValue : 0;
      let endValue = Number(segment.endSeconds);
      if (!Number.isFinite(endValue) || endValue <= startSeconds) {
        const tokenCount = safeText ? safeText.split(/\s+/).length : 0;
        const approx = Math.max(tokenCount * 0.32, 0.6);
        endValue = startSeconds + approx;
      }
      const timeLabel = segment.time || formatSecondsLabel(startSeconds);
      return {
        ...segment,
        info,
        text: safeText,
        seconds: startSeconds,
        endSeconds: endValue,
        time: timeLabel,
      };
    }

    function segmentsSeemContinuous(previous, current) {
      const prevEnd = Number(previous.endSeconds ?? previous.seconds ?? 0);
      const gap = Number(current.seconds ?? 0) - prevEnd;
      if (!Number.isFinite(gap)) return false;
      return gap <= MERGE_GAP_SECONDS && gap >= -0.75;
    }

    function mergeSegmentsBySpeaker(segments) {
      const merged = [];
      segments.forEach((segment) => {
        const normalized = normalizeSegmentTiming(segment);
        if (!normalized.text) {
          return;
        }
        const last = merged[merged.length - 1];
        const sameSpeaker =
          last &&
          normalized.info &&
          last.info &&
          ((normalized.speaker === last.speaker) ||
            (normalized.info.role === last.info.role && normalized.info.label === last.info.label));
        if (last && sameSpeaker && segmentsSeemContinuous(last, normalized)) {
          const combined = `${last.text} ${normalized.text}`.trim();
          last.text = combined.replace(/\s+/g, ' ');
          last.endSeconds = Math.max(last.endSeconds, normalized.endSeconds);
          last.rawParts.push(normalized);
        } else {
          const entry = {
            ...normalized,
            rawParts: normalized.rawParts ? [...normalized.rawParts] : [normalized],
          };
          merged.push(entry);
        }
      });
      return merged;
    }

    function updateCurrentTime() {
      if (currentTimeEl) {
        currentTimeEl.textContent = formatTime(media.currentTime || 0);
      }
      updateActiveWord(media.currentTime || 0);
    }

    function updateVersionButtons() {
      if (!originalButton || !proxyButton) return;
      originalButton.disabled = !workspaceSources.original;
      proxyButton.disabled = false;
      proxyButton.classList.toggle('pending', !workspaceSources.proxy);
      originalButton.classList.toggle('active', currentSourceRole === 'original');
      proxyButton.classList.toggle('active', currentSourceRole === 'proxy');
    }

    function resetPlayerState(message) {
      media.pause();
      mediaSource.removeAttribute('src');
      media.load();
      if (currentTimeEl) currentTimeEl.textContent = '00:00:00';
      if (durationEl) durationEl.textContent = '--:--:--';
      statusLine.textContent = message;
      updateVersionButtons();
    }

    function configureVideoSource(preferredRole) {
      if (preferredRole) {
        currentSourceRole = preferredRole;
      }
      if (currentSourceRole === 'proxy' && !workspaceSources.proxy) {
        currentSourceRole = workspaceSources.original ? 'original' : 'proxy';
      }
      if (currentSourceRole === 'original' && !workspaceSources.original && workspaceSources.proxy) {
        currentSourceRole = 'proxy';
      }

      const url = workspaceSources[currentSourceRole];
      if (!url) {
        resetPlayerState('Select a project with a video file to begin playback.');
        return;
      }

      const fileName = currentSourceRole === 'proxy' ? workspaceFiles.proxy : workspaceFiles.video;
      const wasPaused = media.paused;
      const previousTime = media.currentTime || 0;
      mediaSource.src = url;
      media.load();
      media.addEventListener(
        'loadedmetadata',
        () => {
          if (durationEl) durationEl.textContent = formatTime(media.duration);
          const safeTime = Math.min(previousTime, Math.max(0, media.duration - 0.2));
          media.currentTime = safeTime;
          if (!wasPaused) {
            media.play().catch(() => {});
          }
          updateCurrentTime();
        },
        { once: true },
      );
      statusLine.textContent = `Playing ${describe(fileName)} (${currentSourceRole === 'proxy' ? 'Lightweight' : 'Full Quality'})`;
      updateVersionButtons();
    }

    function computeProxyName() {
      const videoName = workspaceFiles.video;
      if (!videoName) return 'proxy.mp4';
      const lastDot = videoName.lastIndexOf('.');
      const ext = lastDot >= 0 ? videoName.slice(lastDot) : '.mp4';
      const base = lastDot >= 0 ? videoName.slice(0, lastDot) : videoName;
      return `${base}_ultralow${ext}`;
    }

    function showLoader(message) {
      if (!conversionLoader) return;
      conversionLoader.classList.remove('hidden');
      if (loaderFill) loaderFill.style.width = '0';
      if (loaderText) loaderText.textContent = message || 'Preparing…';
    }

    function updateLoader(progress, message) {
      if (loaderFill) {
        loaderFill.style.width = `${Math.max(0, Math.min(progress, 100))}%`;
      }
      if (loaderText && message) {
        loaderText.textContent = message;
      }
    }

    function hideLoader() {
      if (!conversionLoader) return;
      conversionLoader.classList.add('hidden');
    }

    async function ensureProxyExists() {
      if (!workspaceInfo || !workspaceInfo.valid) {
        alert('Open a project with the required files first.');
        return false;
      }
      if (!workspaceFiles.video) {
        alert('No source video found in the current workspace.');
        return false;
      }
      if (workspaceFiles.proxy && workspaceSources.proxy) {
        return true;
      }
      const targetName = workspaceFiles.proxy || computeProxyName();
      showLoader('Starting conversion…');
      try {
        const payload = { source: workspaceFiles.video, target: targetName };
        const response = await fetch('/api/create-proxy', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(payload),
        });
        const data = await response.json();
        if (!response.ok) {
          throw new Error(data.error || response.statusText);
        }
        if (data.status === 'exists') {
          hideLoader();
          await loadWorkspace({ refresh: true });
          return true;
        }
        const jobId = data.job_id;
        if (!jobId) {
          hideLoader();
          await loadWorkspace({ refresh: true });
          return true;
        }
        const job = await waitForJob(jobId, (update) => {
          const progress = update.progress ?? (update.status === 'running' ? 50 : 0);
          updateLoader(progress, `${update.message || 'encoding'} (${progress.toFixed(1)}%)`);
        });
        hideLoader();
        if (job.status === 'completed') {
          await loadWorkspace({ refresh: true });
          return true;
        }
        alert(`Proxy conversion failed: ${job.message || 'Unknown error'}`);
        return false;
      } catch (error) {
        console.error(error);
        hideLoader();
        alert(`Proxy conversion failed: ${error.message}`);
        return false;
      }
    }

    async function applyWorkspaceSummary(summary) {
      workspaceInfo = summary;
      workspaceProjectName = summary && summary.project_name ? summary.project_name : null;
      updateLinks(summary?.path);
      updatePageHeader(summary);
      closeCoverPreview();
      if (!summary || !summary.valid) {
        workspaceProjectName = null;
        workspaceFiles = { notes: null, srt: null, video: null, proxy: null, audio: null, transcript_json: null, chapters: null };
        workspaceSources = { original: null, proxy: null };
        currentSourceRole = 'original';
      transcriptSource = { kind: null, name: null, url: null };
        guestName = '';
        interviewerName = '';
        speakerMap = new Map();
        updateParticipantDisplay();
        resetPlayerState('Workspace not ready. Make sure the project contains a video file.');
        resetTranscript('Open a project with a transcript to preview it here.');
        lastNotesContent = null;
        setTitleFormState({ disabled: true, value: '', status: 'Open a project from Projects →' });
        setParticipantFormState({ disabled: true, interviewer: '', guest: '', status: 'Open a project from Projects →' });
        updateDownloadAllState();
        closeFileManager();
        resetScriptStateCache();
        scriptButtons.forEach((button) => applyScriptVisualState(button));
        return;
    }
    workspaceFiles = Object.assign({ notes: null, srt: null, video: null, proxy: null, audio: null, transcript_json: null, chapters: null }, summary.files);
    workspaceSources = {
      original: workspaceUrl(workspaceFiles.video),
      proxy: workspaceUrl(workspaceFiles.proxy),
    };
    loadScriptStateMap(true);
    scriptButtons.forEach((button, scriptName) => {
      applyScriptVisualState(button, getScriptOutcome(scriptName));
    });
      currentSourceRole = workspaceSources.proxy ? 'proxy' : 'original';
      transcriptSource = { kind: null, name: null, url: null };
      if (workspaceFiles.transcript_json) {
        transcriptSource = { kind: 'json', name: workspaceFiles.transcript_json, url: workspaceUrl(workspaceFiles.transcript_json) };
      } else if (workspaceFiles.srt) {
        transcriptSource = { kind: 'srt', name: workspaceFiles.srt, url: workspaceUrl(workspaceFiles.srt) };
      }
      guestName = '';
      interviewerName = '';
      updateParticipantDisplay();
      updateDownloadAllState();
      setTitleFormState({ disabled: true, value: '', status: 'Loading…' });
      setParticipantFormState({ disabled: true, interviewer: '', guest: '', status: 'Loading…' });
      await loadNotesTitle();
      updateParticipantDisplay();
      if (!workspaceSources.original && !workspaceSources.proxy) {
        resetPlayerState('No video found in this project. Upload an MP4 from the Projects page.');
      } else {
        configureVideoSource();
      }
      if (transcriptSource.kind) {
        await loadTranscript();
      } else {
        resetTranscript('No transcript file detected for this project.', 'Missing');
      }
    }

    async function loadWorkspace({ refresh = false } = {}) {
      try {
        const query = refresh ? '?refresh=1' : '';
        const response = await fetch(`/api/workspace${query}`);
        const data = await response.json();
        await applyWorkspaceSummary(data);
      } catch (error) {
        console.error(error);
        statusLine.textContent = `Unable to load workspace: ${error.message}`;
        resetTranscript('Unable to load workspace details.', 'Error');
        setTitleFormState({ disabled: true, value: '', status: 'Workspace error' });
      }
    }

    function addJobCard(jobId, label) {
      const wrapper = document.createElement('div');
      wrapper.className = 'job-item';
      wrapper.id = `job-${jobId}`;

      const title = document.createElement('h3');
      title.textContent = label;
      wrapper.appendChild(title);

      const status = document.createElement('div');
      status.className = 'job-status';
      status.textContent = 'queued';
      wrapper.appendChild(status);

      const progressBar = document.createElement('div');
      progressBar.className = 'job-progress';
      const progressFill = document.createElement('span');
      progressBar.appendChild(progressFill);
      wrapper.appendChild(progressBar);

      jobList.prepend(wrapper);
      return { wrapper, status, progressFill };
    }

    async function waitForJob(jobId, onUpdate) {
      while (true) {
        const response = await fetch(`/api/jobs/${jobId}`);
        if (!response.ok) break;
        const job = await response.json();
        if (onUpdate) onUpdate(job);
        if (job.status === 'completed' || job.status === 'failed') {
          return job;
        }
        await new Promise((resolve) => setTimeout(resolve, 800));
      }
      return { status: 'failed', message: 'job not found' };
    }

    function scriptStateKey() {
      if (!workspaceInfo || !workspaceInfo.path) return null;
      return `podfree-script-state:${workspaceInfo.path}`;
    }

    function loadScriptStateMap(force = false) {
      const key = scriptStateKey();
      if (!key) {
        scriptStateCache.key = null;
        scriptStateCache.data = {};
        return scriptStateCache.data;
      }
      if (!force && scriptStateCache.key === key) {
        return scriptStateCache.data;
      }
      let parsed = {};
      try {
        const raw = window.localStorage.getItem(key);
        if (raw) {
          const candidate = JSON.parse(raw);
          if (candidate && typeof candidate === 'object') {
            parsed = candidate;
          }
        }
      } catch (error) {
        console.warn('Unable to read stored script state:', error);
      }
      scriptStateCache.key = key;
      scriptStateCache.data = parsed;
      return scriptStateCache.data;
    }

    function persistScriptStateMap() {
      if (!scriptStateCache.key) return;
      try {
        window.localStorage.setItem(scriptStateCache.key, JSON.stringify(scriptStateCache.data));
      } catch (error) {
        console.warn('Unable to persist script state:', error);
      }
    }

    function setScriptOutcome(scriptName, outcome) {
      const map = loadScriptStateMap();
      if (!map) return;
      if (outcome) {
        map[scriptName] = outcome;
      } else {
        delete map[scriptName];
      }
      persistScriptStateMap();
    }

    function getScriptOutcome(scriptName) {
      const map = loadScriptStateMap();
      return map ? map[scriptName] : undefined;
    }

    function resetScriptStateCache() {
      scriptStateCache.key = null;
      scriptStateCache.data = {};
    }

    function applyScriptVisualState(button, outcome) {
      if (!button) return;
      const statusSpan = button.querySelector('.status');
      button.classList.remove('completed', 'failed');
      if (!statusSpan) return;
      if (outcome === 'completed') {
        button.classList.add('completed');
        statusSpan.textContent = 'Done';
      } else if (outcome === 'failed') {
        button.classList.add('failed');
        statusSpan.textContent = 'Failed';
      } else {
        statusSpan.textContent = button.dataset.defaultStatus || 'Idle';
      }
    }

    function coverLabelFromName(name) {
      if (!name) return 'Cover';
      const lowered = String(name).toLowerCase();
      if (lowered.includes('youtube')) return 'YouTube Cover';
      if (lowered.includes('podcast')) return 'Podcast Cover';
      if (lowered.includes('thumb')) return 'Thumbnail';
      return 'Cover';
    }

    function closeCoverPreview() {
      if (!coverPreviewModal) return;
      coverPreviewModal.classList.add('hidden');
      if (coverPreviewBody) {
        coverPreviewBody.textContent = '';
      }
      updateBodyModalState();
    }

    function openCoverPreview(paths) {
      if (!coverPreviewModal || !Array.isArray(paths) || !paths.length) {
        alert('No cover images found yet. Generate them first.');
        return;
      }
      if (!workspaceInfo || !workspaceInfo.path) {
        alert('Open a project before previewing covers.');
        return;
      }
      if (coverPreviewBody) {
        coverPreviewBody.textContent = '';
      }
      let rendered = 0;
      paths.forEach((relative) => {
        const url = workspaceUrl(relative);
        if (!url || !coverPreviewBody) return;
        const card = document.createElement('div');
        card.className = 'cover-card';
        const heading = document.createElement('h3');
        heading.textContent = coverLabelFromName(relative);
        const img = document.createElement('img');
        img.src = url;
        img.alt = heading.textContent;
        img.loading = 'lazy';
        const footer = document.createElement('footer');
        const nameSpan = document.createElement('span');
        nameSpan.textContent = relative;
        const actions = document.createElement('div');
        actions.style.display = 'flex';
        actions.style.gap = '0.4rem';
        const openBtn = document.createElement('button');
        openBtn.type = 'button';
        openBtn.textContent = 'Open';
        openBtn.addEventListener('click', () => {
          window.open(url, '_blank', 'noopener');
        });
        const downloadBtn = document.createElement('button');
        downloadBtn.type = 'button';
        downloadBtn.textContent = 'Download';
        downloadBtn.addEventListener('click', () => {
          triggerDownload(url, relative.split('/').pop());
        });
        actions.appendChild(openBtn);
        actions.appendChild(downloadBtn);
        footer.appendChild(nameSpan);
        footer.appendChild(actions);
        card.appendChild(heading);
        card.appendChild(img);
        card.appendChild(footer);
        coverPreviewBody.appendChild(card);
        rendered += 1;
      });
      if (!rendered) {
        alert('Unable to load covers. They may have been moved or deleted.');
        return;
      }
      coverPreviewModal.classList.remove('hidden');
      updateBodyModalState();
    }

    async function runScript(scriptName, button) {
      const statusSpan = button.querySelector('.status');
      const scriptLabel = button.dataset.label || scriptName;
      try {
        button.disabled = true;
        button.classList.remove('completed', 'failed', 'pending');
        if (statusSpan) statusSpan.textContent = 'Running…';
        const response = await fetch('/api/run-script', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ script: scriptName }),
        });
        const data = await response.json();
        if (!response.ok) {
          throw new Error(data.error || response.statusText);
        }
        const card = addJobCard(data.job_id, `Run ${scriptLabel}`);
        const job = await waitForJob(data.job_id, (update) => {
          card.status.textContent = `${update.status} — ${update.message || ''}`;
          const progress = update.progress ?? (update.status === 'running' ? 50 : 0);
          card.progressFill.style.width = `${Math.min(progress, 100)}%`;
        });
        if (job.status === 'completed') {
          setScriptOutcome(scriptName, 'completed');
          applyScriptVisualState(button, 'completed');
        } else {
          setScriptOutcome(scriptName, 'failed');
          applyScriptVisualState(button, 'failed');
        }
        await loadWorkspace({ refresh: true });
        await loadScripts();
      } catch (error) {
        console.error(error);
        alert(`Failed to run ${scriptName}: ${error.message}`);
        setScriptOutcome(scriptName, 'failed');
        applyScriptVisualState(button, 'failed');
      } finally {
        button.disabled = false;
      }
    }

    function renderScripts(list) {
      loadScriptStateMap();
      toolList.textContent = '';
      scriptButtons.clear();
      
      if (!list.length) {
        const empty = document.createElement('p');
        empty.textContent = 'No scripts found in the Podfree/scripts folder.';
        empty.style.color = 'var(--muted)';
        empty.style.fontSize = '0.85rem';
        toolList.appendChild(empty);
        return;
      }

      // Organize scripts by category
      const categories = {
        'editing': { title: 'Editing', scripts: [] },
        'ai-tools': { title: 'AI Tools', scripts: [] },
        'publishing': { title: 'Publishing', scripts: [] }
      };

      list.forEach((entry) => {
        const { path } = entry;
        const category = path.split('/')[0];
        if (categories[category]) {
          categories[category].scripts.push(entry);
        }
      });

      // Create category boxes
      Object.entries(categories).forEach(([categoryKey, categoryData]) => {
        if (categoryData.scripts.length === 0) return;

        const categoryBox = document.createElement('div');
        categoryBox.className = 'category-box';

        const categoryHeader = document.createElement('div');
        categoryHeader.className = 'category-header';

        const categoryTitle = document.createElement('h3');
        categoryTitle.className = 'category-title';
        categoryTitle.textContent = categoryData.title;

        const playButton = document.createElement('button');
        playButton.className = 'category-play-btn';
        playButton.innerHTML = '▶ Run All';
        playButton.addEventListener('click', () => runCategoryScripts(categoryData.scripts));

        categoryHeader.appendChild(categoryTitle);
        categoryHeader.appendChild(playButton);

        const scriptsContainer = document.createElement('div');
        scriptsContainer.className = 'category-scripts';

        categoryData.scripts.forEach((entry) => {
          const { name, path, label, status, outputs = [] } = entry;
          const wrapper = document.createElement('div');
          wrapper.className = 'tool-entry';

          const button = document.createElement('button');
          button.type = 'button';
          button.className = 'tool-button';
          button.dataset.script = name;
          button.dataset.label = label;

          let statusText = 'Idle';
          if (status === 'ready') {
            statusText = 'Ready';
          } else if (status === 'missing') {
            statusText = 'Missing';
          }

          button.dataset.defaultStatus = statusText;
          button.innerHTML = `<span>${label}</span><span class="status">${statusText}</span>`;
          button.addEventListener('click', () => runScript(path, button));
          wrapper.appendChild(button);

          if (outputs && outputs.length) {
            button.title = `Outputs:\n${outputs.join('\n')}`;
            const outputNote = document.createElement('div');
            outputNote.className = 'tool-output';
            outputNote.textContent = `Outputs: ${outputs.join(', ')}`;
            wrapper.appendChild(outputNote);
          }

          if (name === 'generate_covers.py' && outputs && outputs.length) {
            const coverPaths = outputs.slice();
            const previewBtn = document.createElement('button');
            previewBtn.type = 'button';
            previewBtn.className = 'cover-preview-button';
            previewBtn.innerHTML = '<svg viewBox="0 0 24 24" aria-hidden="true"><path d="M4 5a3 3 0 0 1 3-3h10a3 3 0 0 1 3 3v14a2 2 0 0 1-2 2H5a1 1 0 0 1-1-1V5Z" opacity="0.35"/><path d="M16.25 12.25 14.5 14.5l-2-2.25L8 17h10l-1.75-4.75Z" /><circle cx="9" cy="8" r="1.5" /></svg><span>View Covers</span>';
            previewBtn.addEventListener('click', () => openCoverPreview(coverPaths));
            wrapper.appendChild(previewBtn);
          }

          scriptsContainer.appendChild(wrapper);
          scriptButtons.set(name, button);
          const persistedOutcome = getScriptOutcome(name);
          if (persistedOutcome) {
            applyScriptVisualState(button, persistedOutcome);
          } else if (outputs && outputs.length) {
            applyScriptVisualState(button, 'completed');
          } else {
            applyScriptVisualState(button, null);
          }
        });

        categoryBox.appendChild(categoryHeader);
        categoryBox.appendChild(scriptsContainer);
        toolList.appendChild(categoryBox);
      });
    }

    async function runCategoryScripts(scripts) {
      if (!scripts || scripts.length === 0) {
        alert('No scripts to run in this category.');
        return;
      }

      const confirmed = confirm(`Run all ${scripts.length} scripts in this category? This will execute them sequentially.`);
      if (!confirmed) return;

      for (const script of scripts) {
        const { path, name } = script;
        const button = scriptButtons.get(name);
        if (button) {
          await runScript(path, button);
          // Small delay between scripts
          await new Promise(resolve => setTimeout(resolve, 1000));
        }
      }
    }

    async function loadScripts() {
      try {
        const response = await fetch('/api/scripts');
        if (!response.ok) {
          throw new Error(await response.text());
        }
        const data = await response.json();
        renderScripts(data.scripts || []);
      } catch (error) {
        console.error(error);
        alert('Unable to load script list: ' + error.message);
      }
    }

    if (refreshScriptsBtn) {
      refreshScriptsBtn.addEventListener('click', loadScripts);
    }

    if (versionToggle) {
      versionToggle.addEventListener('click', async (event) => {
        const button = event.target.closest('button[data-role]');
        if (!button) return;
        const role = button.dataset.role;
        if (role === 'proxy' && !workspaceSources.proxy) {
          const created = await ensureProxyExists();
          if (created) {
            configureVideoSource('proxy');
          }
          return;
        }
        configureVideoSource(role);
      });
    }

    media.addEventListener('timeupdate', updateCurrentTime);
    media.addEventListener('seeked', updateCurrentTime);
    media.addEventListener('loadeddata', updateCurrentTime);

    if (titleForm) {
      titleForm.addEventListener('submit', async (event) => {
        event.preventDefault();
        if (!titleInput || !titleSave) return;
        const newTitle = titleInput.value.trim();
        if (!newTitle) {
          setTitleFormState({ disabled: false, value: '', status: 'Title cannot be empty' });
          return;
        }
        if (!lastNotesContent) {
          await loadNotesTitle();
          if (!lastNotesContent) {
            setTitleFormState({ disabled: true, value: newTitle, status: 'Notes unavailable' });
            return;
          }
        }
        setTitleFormState({ disabled: true, value: newTitle, status: 'Saving…' });
        try {
          const updated = replaceTitleSection(lastNotesContent, newTitle);
          const response = await fetch('/api/notes', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ content: updated }),
          });
          if (!response.ok) {
            throw new Error(await response.text());
          }
          const data = await response.json();
          lastNotesContent = updated;
          const savedTitle = extractTitleSection(updated);
          setTitleFormState({ disabled: false, value: savedTitle, status: `Saved at ${new Date().toLocaleTimeString()}` });
        } catch (error) {
          console.error(error);
          setTitleFormState({ disabled: false, value: newTitle, status: 'Save failed' });
          alert('Unable to update title: ' + error.message);
        }
      });
    }

    setTitleFormState({ disabled: true, value: '', status: 'Open a project from Projects →' });

    // Check session on page load
    async function checkSessionOnLoad() {
      try {
        const response = await originalFetch('/api/workspace');
        if (response.status === 401) {
          redirectToLogin();
          return false;
        }
        return true;
      } catch (error) {
        console.error('Session check failed:', error);
        return false;
      }
    }

    (async () => {
      const sessionValid = await checkSessionOnLoad();
      if (!sessionValid) return;
      
      await applyWorkspaceFromQuery();
      await applyPendingWorkspace();
      await loadWorkspace();
      await loadScripts();
    })();
  </script>
</body>
</html>
